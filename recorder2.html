<!DOCTYPE html>
<html lang="en">
<head>
    <title>Genealogy Record Editor</title>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com;">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 18px;
            padding: 20px;
            max-width: 100%;
            margin: 0 auto;
        }
        .task-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .task-btn {
            font-size: 20px;
            padding: 8px 16px;
            border-radius: 8px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            min-width: 150px;
            touch-action: manipulation;
        }
        .task-btn:hover:not(.disabled-btn) {
            background-color: #0056b3;
        }
        .disabled-btn {
            background-color: #cccccc;
            cursor: not-allowed;
            pointer-events: none;
        }
        .file-status {
            font-size: 16px;
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            float: right;
            font-size: 24px;
            cursor: pointer;
        }
        .modal-content h3 {
            margin-top: 0;
            font-size: 24px;
        }
        .modal-content label {
            display: block;
            margin: 10px 0 5px;
            font-size: 18px;
        }
        .modal-content input, .modal-content select, .modal-content textarea {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .modal-content button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 18px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .modal-content button:hover {
            background-color: #218838;
        }
        .table-container {
            margin-top: 20px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            font-size: 14px;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px;
            border: 1px solid #ccc;
            white-space: normal;
            box-sizing: border-box;
        }
        th.vestigial {
            padding: 4px;
        }
        th.record_type, td.record_type {
            width: 60px;
        }
        th.gen, td.gen {
            width: 40px;
        }
        th.sex, td.sex {
            width: 40px;
        }
        th.record_type.vestigial, td.record_type.vestigial,
        th.gen.vestigial, td.gen.vestigial,
        th.name.vestigial, td.name.vestigial,
        th.sex.vestigial, td.sex.vestigial {
            width: inherit !important;
        }
        .action-icons {
            font-size: 24px;
            margin-right: 4px;
        }
        .vestigial {
            width: 36px !important;
            max-width: 36px !important;
            min-width: 0 !important;
            overflow: hidden;
        }
        .vestigial .header-text {
            display: none;
        }
        .vestigial .cell-content {
            display: none;
        }
        .editable-row:hover {
            background-color: #d9edf7;
        }
        .highlighted-row {
            background-color: #ffffcc !important;
        }
        .greyed-out {
            background-color: #c0c0c0;
            cursor: not-allowed;
        }
        @media (max-width: 768px) {
            .task-btn {
                width: 100%;
                margin-bottom: 10px;
            }
            .modal-content {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <h2>Genealogy Recorder</h2>
    <div class="info">
        <p><strong>Version:</strong> <span id="pageVersion">1.0.16.4</span> <strong>Last Updated:</strong> <span id="pageDate">2025-09-19 13:08:00 PDT</span></p>
        <p class="warning">Data is deleted when you leave this page. Download your changes!</p>
    </div>
    <div class="task-buttons">
        <button onclick="openModal('addChild')" class="task-btn disabled-btn" id="addChildBtn">Add Child üë∂</button>
        <button onclick="openModal('addSpouse')" class="task-btn disabled-btn" id="addSpouseBtn">Add Partner üíç</button>
        <button onclick="openModal('updateRecord')" class="task-btn disabled-btn" id="updateRecordBtn">Update Record ‚úèÔ∏è</button>
        <button onclick="openModal('recordDeathBurial')" class="task-btn disabled-btn" id="recordDeathBurialBtn">Record Death/Burial ‚ö∞Ô∏è</button>
        <button onclick="toggleTable()" class="task-btn disabled-btn" id="viewTableBtn">View Table üìã</button>
        <button onclick="selectAndLoadFile()" class="task-btn" id="selectLoadBtn">Select/Load File üìÇ</button>
        <button onclick="downloadCSV()" class="task-btn" id="returnUpdatesBtn" style="display: none;">Return Updates üìß</button>
    </div>
    <div class="file-status">
        <span id="fileStatus">No file selected</span>
    </div>
    <input type="file" id="textFile" accept=".csv.enc,.zip" style="display: none;" onchange="handleFileSelect()">
    <div id="tableContainer" class="table-container" style="display: none;">
        <div id="recordBody"></div>
    </div>
    <div id="modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="modalTitle"></h3>
            <form id="modalForm"></form>
        </div>
    </div>

    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        var decryptionPassphrase = null;
        let modalMode = null;
        let records = [];
        let originalFileName = 'records.csv.enc';
        let editingIndex = null;
        let editingField = null;
        let highlightedRow = null;
        let vestigialColumns = new Set();
        let debugMode = false;
        let renderTimeout = null;
        const dateFields = ['birth_date', 'death_date', 'marriage_date'];

        if (location.search.includes('debug=1')) {
            debugMode = true;
            console.log('Debug mode enabled');
        }

        function selectAndLoadFile() {
            document.getElementById('textFile').click();
        }

        function handleFileSelect() {
            const fileInput = document.getElementById('textFile');
            const fileStatus = document.getElementById('fileStatus');
            if (fileInput.files.length > 0) {
                fileStatus.textContent = `Selected: ${fileInput.files[0].name}`;
                if (debugMode) console.log(`File selected: ${fileInput.files[0].name}`);
                processFile();
            } else {
                fileStatus.textContent = 'No file selected';
                if (debugMode) console.log('No file selected');
            }
        }

        function getPassphrase(callback, fileName) {
            openModal('passphrase');
            document.getElementById('modalTitle').textContent = `Enter Passphrase for ${fileName || 'file'}`;
            const form = document.getElementById('modalForm');
            form.innerHTML = `
                <label>Passphrase</label>
                <input type="password" name="passphrase" autocomplete="off" onkeydown="if (event.key === 'Enter') event.preventDefault();">
                <button type="button" onclick="submitPassphrase('${callback}')">Submit</button>
            `;
            if (debugMode) console.log('Modal opened for mode: passphrase');
        }

        function submitPassphrase(callback) {
            const passphrase = document.querySelector('#modalForm input[name="passphrase"]').value;
            if (passphrase) {
                decryptionPassphrase = passphrase;
                closeModal();
                if (debugMode) console.log('Modal closed');
                window[callback]();
            } else {
                alert('Passphrase is required.');
                document.getElementById('fileStatus').textContent = 'No file selected';
                document.getElementById('textFile').value = '';
            }
        }

        function processFile() {
            const fileInput = document.getElementById('textFile');
            const file = fileInput.files[0];
            const fileStatus = document.getElementById('fileStatus');
            if (!file) {
                fileStatus.textContent = 'No file selected';
                alert('No file selected. Please try again.');
                if (debugMode) console.log('No file selected in processFile');
                return;
            }
            if (typeof CryptoJS === 'undefined') {
                fileStatus.textContent = 'No file selected';
                alert('Crypto library not loaded. Please refresh the page and try again.');
                fileInput.value = '';
                return;
            }
            originalFileName = file.name;
            if (debugMode) console.log(`Processing file: ${file.name}`);
            const reader = new FileReader();
            reader.onload = function(e) {
                if (typeof CryptoJS === 'undefined') {
                    fileStatus.textContent = 'No file selected';
                    alert('Crypto library failed to load during file read. Please refresh and retry.');
                    fileInput.value = '';
                    return;
                }
                if (typeof decryptFile === 'undefined') {
                    fileStatus.textContent = 'No file selected';
                    alert('Decryption function not ready‚Äîplease refresh and try again.');
                    fileInput.value = '';
                    return;
                }
                if (file.name.toLowerCase().endsWith('.zip')) {
                    if (typeof JSZip === 'undefined') {
                        fileStatus.textContent = 'No file selected';
                        alert('ZIP support requires JSZip library‚Äîplease refresh the page.');
                        fileInput.value = '';
                        return;
                    }
                    const zip = new JSZip();
                    zip.loadAsync(e.target.result).then((contents) => {
                        let foundFile = null;
                        contents.forEach((relativePath, zipEntry) => {
                            if ((zipEntry.name.endsWith('.csv.enc') || (debugMode && zipEntry.name.endsWith('.csv'))) && !foundFile) {
                                foundFile = { name: zipEntry.name, entry: zipEntry };
                                if (debugMode) console.log(`Found matching file in ZIP: ${zipEntry.name}`);
                            }
                        });
                        if (foundFile) {
                            foundFile.entry.async('arraybuffer').then((data) => {
                                originalFileName = foundFile.name;
                                if (foundFile.name.endsWith('.csv.enc')) {
                                    getPassphrase('processZipFile', foundFile.name);
                                    window.processZipFile = () => {
                                        const result = decryptFile(data, decryptionPassphrase);
                                        if (typeof result === 'string') {
                                            records = parseCSVFile(result);
                                            if (debugMode) console.log(`Decryption: data length=${result.length} bytes`);
                                            if (debugMode) console.log(`Salt (hex): ${CryptoJS.lib.WordArray.random(16).toString(CryptoJS.enc.Hex)}`);
                                            if (debugMode) console.log(`IV (hex): ${CryptoJS.lib.WordArray.random(16).toString(CryptoJS.enc.Hex)}`);
                                            if (debugMode) console.log(`Key (hex): ${CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Hex)}`);
                                            if (debugMode) console.log(`Decrypted data (first 100 chars): ${result.slice(0, 100)}`);
                                            if (debugMode) console.log(`Parsed ${records.length} records`);
                                            enableButtonsAfterLoad();
                                            debounceDisplayRecords();
                                            fileStatus.textContent = `Loaded: ${foundFile.name}`;
                                        } else {
                                            fileStatus.textContent = 'No file selected';
                                            alert(`Decryption failed: ${result.error}`);
                                            decryptionPassphrase = null;
                                            fileInput.value = '';
                                        }
                                    };
                                } else if (debugMode && foundFile.name.endsWith('.csv')) {
                                    const text = arrayBufferToBinary(data);
                                    records = parseCSVFile(text);
                                    decryptionPassphrase = null;
                                    if (debugMode) console.log(`Parsed ${records.length} records`);
                                    enableButtonsAfterLoad();
                                    debounceDisplayRecords();
                                    fileStatus.textContent = `Loaded: ${foundFile.name}`;
                                } else {
                                    fileStatus.textContent = 'No file selected';
                                    alert(`Unsupported file type in ZIP: ${foundFile.name}. Expected .csv.enc${debugMode ? ' or .csv' : ''}.`);
                                    fileInput.value = '';
                                }
                            }).catch((err) => {
                                fileStatus.textContent = 'No file selected';
                                alert(`Error extracting file from ZIP: ${err.message}`);
                                fileInput.value = '';
                                if (debugMode) console.log('Error in ZIP extraction:', err);
                            });
                        } else {
                            fileStatus.textContent = 'No file selected';
                            alert(`No .csv.enc${debugMode ? ' or .csv' : ''} file found in ZIP. Please check contents.`);
                            fileInput.value = '';
                        }
                    }).catch((err) => {
                        fileStatus.textContent = 'No file selected';
                        alert(`Error reading ZIP: ${err.message}. Try unzipping manually.`);
                        fileInput.value = '';
                        if (debugMode) console.log('Error in ZIP loading:', err);
                    });
                } else if (file.name.endsWith('.csv.enc')) {
                    getPassphrase('processEncryptedFile', file.name);
                    window.processEncryptedFile = () => {
                        const result = decryptFile(e.target.result, decryptionPassphrase);
                        if (typeof result === 'string') {
                            records = parseCSVFile(result);
                            if (debugMode) console.log(`Decryption: data length=${result.length} bytes`);
                            if (debugMode) console.log(`Salt (hex): ${CryptoJS.lib.WordArray.random(16).toString(CryptoJS.enc.Hex)}`);
                            if (debugMode) console.log(`IV (hex): ${CryptoJS.lib.WordArray.random(16).toString(CryptoJS.enc.Hex)}`);
                            if (debugMode) console.log(`Key (hex): ${CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Hex)}`);
                            if (debugMode) console.log(`Decrypted data (first 100 chars): ${result.slice(0, 100)}`);
                            if (debugMode) console.log(`Parsed ${records.length} records`);
                            enableButtonsAfterLoad();
                            debounceDisplayRecords();
                            fileStatus.textContent = `Loaded: ${file.name}`;
                        } else {
                            fileStatus.textContent = 'No file selected';
                            alert(`Decryption failed: ${result.error}`);
                            decryptionPassphrase = null;
                            fileInput.value = '';
                        }
                    };
                } else if (debugMode && file.name.toLowerCase().endsWith('.csv')) {
                    const text = e.target.result;
                    records = parseCSVFile(text);
                    decryptionPassphrase = null;
                    if (debugMode) console.log(`Parsed ${records.length} records`);
                    enableButtonsAfterLoad();
                    debounceDisplayRecords();
                    fileStatus.textContent = `Loaded: ${file.name}`;
                } else {
                    fileStatus.textContent = 'No file selected';
                    alert(`Unsupported file type: ${file.name}. Expected .csv.enc${debugMode ? ' or .csv' : ''}.`);
                    fileInput.value = '';
                    return;
                }
            };
            if (file.name.toLowerCase().endsWith('.zip') || file.name.endsWith('.csv.enc') || (debugMode && file.name.toLowerCase().endsWith('.csv'))) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        function enableButtonsAfterLoad() {
            document.getElementById('addChildBtn').classList.remove('disabled-btn');
            document.getElementById('addSpouseBtn').classList.remove('disabled-btn');
            document.getElementById('updateRecordBtn').classList.remove('disabled-btn');
            document.getElementById('recordDeathBurialBtn').classList.remove('disabled-btn');
            document.getElementById('viewTableBtn').classList.remove('disabled-btn');
            document.getElementById('selectLoadBtn').style.display = 'none';
            document.getElementById('returnUpdatesBtn').style.display = 'block';
            if (debugMode) console.log('Enabled task buttons and toggled Select/Load to Return Updates');
        }

        function filledCell(cell) {
            return cell !== '' && cell != null;
        }

        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }

        function isValidDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return true;
            const parts = dateStr.split('-');
            if (parts.length === 1) {
                const year = parseInt(parts[0], 10);
                return !isNaN(year) && year >= 1 && year <= 9999;
            } else if (parts.length === 2) {
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                return !isNaN(year) && !isNaN(month) && year >= 1 && year <= 9999 && month >= 1 && month <= 12;
            } else if (parts.length === 3) {
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                const day = parseInt(parts[2], 10);
                const date = new Date(year, month - 1, day);
                return !isNaN(date.getTime()) && date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
            }
            return false;
        }

        function openModal(mode) {
            modalMode = mode;
            const modal = document.getElementById('modal');
            const form = document.getElementById('modalForm');
            modal.style.display = 'flex';
            if (debugMode) console.log(`Modal opened for mode: ${mode}`);

            if (mode === 'passphrase') {
                form.innerHTML = `
                    <label>Passphrase</label>
                    <input type="password" name="passphrase" autocomplete="off" onkeydown="if (event.key === 'Enter') event.preventDefault();">
                    <button type="button" onclick="submitPassphrase('processEncryptedFile')">Submit</button>
                `;
            } else if (mode === 'updateRecord') {
                const recordOptions = records.map(r => `<option value="${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}">${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}</option>`).join('');
                const fieldOptions = Object.keys(records[0] || {}).filter(f => f !== 'record_type' && f !== 'gen').map(f => `<option value="${f}">${f}</option>`).join('');
                form.innerHTML = `
                    <label>Record</label>
                    <select name="record">${recordOptions}</select>
                    <label>Field</label>
                    <select name="field">${fieldOptions}</select>
                    <label>Value</label>
                    <input type="text" name="value">
                    <button type="button" onclick="saveModalData('updateRecord')">Save</button>
                `;
            } else if (mode === 'addChild' || mode === 'addSpouse' || mode === 'recordDeathBurial') {
                const recordOptions = records.map(r => `<option value="${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}">${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}</option>`).join('');
                form.innerHTML = `
                    <label>Record</label>
                    <select name="record">${recordOptions}</select>
                    ${mode === 'addChild' ? '<label>Name</label><input type="text" name="name">' : ''}
                    ${mode === 'addSpouse' ? '<label>Partner Name</label><input type="text" name="name">' : ''}
                    ${mode === 'recordDeathBurial' ? `
                        <label>Death Date</label><input type="text" name="death_date" placeholder="YYYY-MM-DD">
                        <label>Death Location</label><input type="text" name="death_location">
                        <label>Burial Location</label><input type="text" name="burial_location">
                    ` : ''}
                    <button type="button" onclick="saveModalData('${mode}')">Save</button>
                `;
            }
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.style.display = 'none';
            document.getElementById('modalForm').innerHTML = '';
            modalMode = null;
            if (debugMode) console.log('Modal closed');
        }

        function saveModalData(mode) {
            if (debugMode) console.log(`Saving modal data for mode: ${mode} - Start`);
            const form = document.getElementById('modalForm');
            const data = {};
            for (let input of form.elements) {
                if (input.name) data[input.name] = input.value;
            }
            if (debugMode) console.log(`Collected data:`, data);

            if (mode === 'updateRecord') {
                if (debugMode) console.log(`Validating updateRecord data`);
                if (!data.record || !data.field || !data.value) {
                    alert('Please select a record, field, and enter a value.');
                    if (debugMode) console.log('Validation failed: Missing required fields');
                    return;
                }
                if (dateFields.includes(data.field) && !isValidDate(data.value)) {
                    alert('Invalid date. Use YYYY, YYYY-MM, or YYYY-MM-DD.');
                    if (debugMode) console.log(`Validation failed for ${data.field}: ${data.value}`);
                    return;
                }
                if (data.field === 'relationship' && !['Spouse', 'Other'].includes(data.value)) {
                    alert('Relationship must be "Spouse" or "Other".');
                    if (debugMode) console.log(`Validation failed for relationship: ${data.value}`);
                    return;
                }
                const [recordType, name] = data.record.split(': ');
                const record = records.find(r => (r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type) === recordType && r.name === name);
                if (!record) {
                    alert('Invalid record selected.');
                    if (debugMode) console.log('Validation failed: Invalid record');
                    return;
                }
                if (isFieldEditable(record.record_type, data.field)) {
                    if (debugMode) console.log(`Updating ${data.field} to ${data.value} for record: ${name}`);
                    record[data.field] = data.value;
                } else {
                    alert('Selected field is not editable.');
                    if (debugMode) console.log('Validation failed: Field not editable');
                    return;
                }
            } else if (mode === 'addChild') {
                if (!data.record || !data.name) {
                    alert('Please select a record and enter a name.');
                    return;
                }
                const [recordType, parentName] = data.record.split(': ');
                records.push({
                    record_type: 'person',
                    gen: records.find(r => r.name === parentName).gen + 1,
                    name: data.name,
                    gender: '',
                    birth_date: '',
                    birth_location: '',
                    death_date: '',
                    death_location: '',
                    burial_location: '',
                    service: '',
                    marriage_date: '',
                    relationship: 'Child',
                    divorced: '',
                    parents: parentName
                });
            } else if (mode === 'addSpouse') {
                if (!data.record || !data.name) {
                    alert('Please select a record and enter a partner name.');
                    return;
                }
                const [recordType, spouseName] = data.record.split(': ');
                records.push({
                    record_type: 'spouse',
                    gen: records.find(r => r.name === spouseName).gen,
                    name: data.name,
                    gender: '',
                    birth_date: '',
                    birth_location: '',
                    death_date: '',
                    death_location: '',
                    burial_location: '',
                    service: '',
                    marriage_date: '',
                    relationship: 'Spouse',
                    divorced: '',
                    parents: ''
                });
            } else if (mode === 'recordDeathBurial') {
                if (!data.record || !data.death_date || !isValidDate(data.death_date)) {
                    alert('Please select a record and enter a valid death date (YYYY-MM-DD).');
                    return;
                }
                const [recordType, name] = data.record.split(': ');
                const record = records.find(r => (r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type) === recordType && r.name === name);
                record.death_date = data.death_date;
                record.death_location = data.death_location || '';
                record.burial_location = data.burial_location || '';
            }

            try {
                if (debugMode) console.log('Attempting to save and close modal');
                closeModal();
                debounceDisplayRecords();
                if (debugMode) console.log(`Saved ${mode} data successfully:`, data);
            } catch (error) {
                if (debugMode) console.log('Error during save operation:', error);
            }
        }

        function isFieldEditable(recordType, field) {
            const editableFields = {
                'person': ['name', 'gender', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service'],
                'spouse': ['name', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service', 'marriage_date', 'relationship', 'divorced', 'parents']
            };
            if (debugMode) console.log(`Checking editable: record_type='${recordType}', field=${field}, isEditable=${editableFields[recordType]?.includes(field) || false}`);
            return editableFields[recordType]?.includes(field) || false;
        }

        function isFieldGreyedOut(recordType, field) {
            const greyedOutFields = {
                'person': ['marriage_date', 'relationship', 'divorced', 'parents'],
                'spouse': ['gen', 'gender']
            };
            if (debugMode) console.log(`Checking greyed-out: record_type='${recordType}', field=${field}, isGreyedOut=${greyedOutFields[recordType]?.includes(field) || false}`);
            return greyedOutFields[recordType]?.includes(field) || false;
        }

        function debounceDisplayRecords() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(displayRecords, 100);
            if (debugMode) console.log('Debouncing display records');
        }

        function displayRecords() {
            const container = document.getElementById('recordBody');
            if (!container) return;
            container.innerHTML = '';
            if (records.length === 0) {
                container.innerHTML = '<p>No records to display.</p>';
                return;
            }
            const table = document.createElement('table');
            let headers = Object.keys(records[0]);
            headers = headers.filter(h => !vestigialColumns.has(h));
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header.replace(/_/g, ' ');
                if (vestigialColumns.has(header)) th.classList.add('vestigial');
                if (header === 'record_type') th.classList.add('record_type');
                else if (header === 'gen') th.classList.add('gen');
                else if (header === 'sex' || header === 'gender') th.classList.add('sex');
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);

            records.forEach((record, index) => {
                const row = document.createElement('tr');
                row.classList.add('editable-row');
                if (index === highlightedRow) row.classList.add('highlighted-row');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = record[header] || '';
                    if (vestigialColumns.has(header)) td.classList.add('vestigial');
                    if (!isFieldEditable(record.record_type, header)) td.classList.add('greyed-out');
                    else if (isFieldGreyedOut(record.record_type, header)) td.classList.add('greyed-out');
                    row.appendChild(td);
                });
                table.appendChild(row);
            });
            container.appendChild(table);
            if (debugMode) console.log('Records displayed');
        }

        function toggleTable() {
            const container = document.getElementById('tableContainer');
            container.style.display = container.style.display === 'none' ? 'block' : 'none';
            if (debugMode) console.log(`Table toggled: ${container.style.display === 'none' ? 'hidden' : 'shown'}`);
            if (container.style.display !== 'none') debounceDisplayRecords();
        }

        function downloadCSV() {
            const csvContent = 'data:text/csv;charset=utf-8,' + encodeURIComponent(convertToCSV(records));
            const link = document.createElement('a');
            link.setAttribute('href', csvContent);
            link.setAttribute('download', originalFileName.replace('.enc', '') || 'records.csv');
            link.click();
        }

        function convertToCSV(arr) {
            const array = [Object.keys(arr[0])].concat(arr);
            return array.map(row => Object.values(row).map(value => `"${value}"`).join(',')).join('\n');
        }

        function parseCSVFile(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const result = [];
            for (let i = 1; i < lines.length; i++) {
                const obj = {};
                const currentLine = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                for (let j = 0; j < headers.length; j++) {
                    obj[headers[j]] = currentLine[j] || '';
                }
                result.push(obj);
            }
            return result;
        }

        function arrayBufferToBinary(buffer) {
            const binary = new Uint8Array(buffer);
            let binaryString = '';
            for (let i = 0; i < binary.length; i++) {
                binaryString += String.fromCharCode(binary[i]);
            }
            return binaryString;
        }

        window.addEventListener('unload', () => {
            records = [];
            decryptionPassphrase = null;
        });

        // Placeholder for decryption function (to be implemented with CryptoJS)
        function decryptFile(data, passphrase) {
            try {
                const salt = CryptoJS.lib.WordArray.random(16);
                const iv = CryptoJS.lib.WordArray.random(16);
                const key = CryptoJS.PBKDF2(passphrase, salt, { keySize: 32, iterations: 1000 });
                const encrypted = CryptoJS.AES.encrypt(data, key, { iv: iv }).toString();
                return CryptoJS.AES.decrypt(encrypted, key, { iv: iv }).toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return { error: e.message };
            }
        }
    </script>
</body>
</html>
