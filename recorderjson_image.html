<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Genealogy Record Editor</title>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://unpkg.com;">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <script src="https://unpkg.com/sortablejs@1.15.3/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js" crossorigin="anonymous"></script>
    <script src="config.js"></script>
    <style>
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;font-size:18px;padding:20px;max-width:100%;margin:0 auto}
        .task-buttons{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;margin-bottom:20px}
        .task-btn{font-size:16.2px !important;padding:6.5px 13px !important;min-width:122px !important;border-radius:7.2px;background:#007bff;color:white;border:none;cursor:pointer;touch-action:manipulation}
        .task-btn:hover:not(.disabled-btn){background:#0056b3}
        .disabled-btn{background:#ccc;cursor:not-allowed;pointer-events:none}
        .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000}
        .modal-content{background:white;padding:20px;border-radius:10px;width:90%;max-width:420px;max-height:80vh;overflow-y:auto;box-shadow:0 4px 12px rgba(0,0,0,0.2)}
        .close{float:right;font-size:24px;cursor:pointer}
        .modal-content h3{margin-top:0;font-size:24px;text-align:center}
        .modal-content label{display:block;margin:10px 0 5px;font-size:18px}
        .modal-content input,.modal-content select,.modal-content textarea{width:100%;padding:10px;font-size:18px;border:1px solid #ccc;border-radius:5px;box-sizing:border-box}
        .modal-content button{margin-top:20px;padding:12px 24px;font-size:18px;background:#28a745;color:white;border:none;border-radius:5px;cursor:pointer;width:100%;transition:background 0.2s}
        .modal-content button:hover{background:#218838}
        .note{font-size:15px;color:#555;margin-top:20px;line-height:1.4;background:#f8f9fa;padding:12px;border-radius:6px}
        .table-container{margin-top:20px;overflow-x:auto}
        table{width:100%;font-size:14px;border-collapse:collapse}
        th,td{padding:8px;border:1px solid #ccc;white-space:normal;box-sizing:border-box}
        th.vestigial{padding:4px}
        th.record_type,td.record_type{width:60px}
        th.gen,td.gen{width:40px}
        th.sex,td.sex{width:40px}
        .vestigial{width:36px!important;max-width:36px!important;min-width:0!important;overflow:hidden}
        .vestigial .header-text,.vestigial .cell-content{display:none}
        .editable-row:hover{background:#d9edf7}
        .highlighted-row{background:#ffffcc!important}
        .greyed-out{background:#c0c0c0;cursor:not-allowed}
        @media(max-width:768px){.task-btn{width:100%;margin-bottom:10px}.modal-content{width:95%;max-width:350px}}
        .title-container{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:20px}
        .title-left{flex:1}
        .title-right{text-align:right}
        .status-line{margin-top:8px;font-size:16px;color:#333;display:block}
    </style>
</head>
<body>
    <div class="title-container">
        <div class="title-left">
            <h2>Genealogy Recorder
                <span style="font-size:14px;">
                    Version: <span id="pageVersion">2.0.32</span> ‚Äî December 20, 2025
                </span>
            </h2>
            <span class="status-line" id="fileStatus">No records loaded</span>
        </div>
        <div class="title-right">
            <button onclick="openFeedbackModal()" class="task-btn" style="background:#007bff;font-size:15px;padding:6px 12px;min-width:auto">Provide Feedback</button>
        </div>
    </div>

    <div class="info">
        <p class="warning">Data is deleted when you leave this page. Hit "Return Updates" when complete, to save your changes!</p>
    </div>

    <div class="task-buttons" id="taskButtons">
        <button type="button" onclick="loadFromDropbox()" class="task-btn" id="selectLoadBtn">Load Records üìÇ</button>
        <button type="button" onclick="openRequestModal()" class="task-btn" id="requestEditBtn">Request Edit Package ‚úâÔ∏è</button>
        <button type="button" onclick="openModal('addChild')" class="task-btn disabled-btn" id="addChildBtn" style="display:none">Add Child üë∂</button>
        <button type="button" onclick="openModal('addPartner')" class="task-btn disabled-btn" id="addPartnerBtn" style="display:none">Add Partner üíç</button>
        <button type="button" onclick="openModal('addParent')" class="task-btn disabled-btn" id="addParentBtn" style="display:none">Add Parent üë§‚Üë</button>
        <button type="button" onclick="openModal('updateRecord')" class="task-btn disabled-btn" id="updateRecordBtn" style="display:none">Update Record ‚úèÔ∏è</button>
        <button type="button" onclick="openModal('recordDeathBurial')" class="task-btn disabled-btn" id="recordDeathBurialBtn" style="display:none">Record Death/Burial ‚ö∞Ô∏è</button>
        <button type="button" onclick="openStoryModal()" class="task-btn" id="editStoryBtn" style="display:none">Edit Story</button>
        <button type="button" onclick="toggleTable()" class="task-btn disabled-btn" id="viewTableBtn" style="display:none">View Table üìã</button>
        <button type="button" onclick="downloadUpdates()" class="task-btn" id="returnUpdatesBtn" style="display:none">Return Updates üì§</button>
        <button type="button" onclick="exitApp()" class="task-btn" id="exitBtn" style="display:none">Exit üö™</button>
    </div>

    <input type="file" id="textFile" accept=".zip,.json" style="display:none;" onchange="handleFileSelect()">
    <div id="tableContainer" class="table-container" style="display:none;">
        <div id="recordBody"></div>
    </div>

    <div id="modal" class="modal" style="display:none;">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="modalTitle"></h3>
            <form id="modalForm" autocomplete="off"></form>
        </div>
    </div>

    <script>
        let records = [], decryptionPassphrase = null, exchangePassphrase = null, originalFileName = 'records.zip';
        let debugMode = false, isEncryptedZip = false;
        let modalMode = null, editingIndex = null, editingField = null;
        let vestigialColumns = new Set(['notes', 'unprocessed_items']);
        let renderTimeout = null;
        let ticketNumber = null;
        let hasReturnedUpdates = false;
        let originalHeader = {};   // will keep everything that was outside the "data" array when loading
        const debugPassphraseHash = '0be92202d0978436fce6d8c863f4a2a3d63711a4e4444cb0734beea27315f2a5';
        const dateFields = ['birth_date', 'death_date', 'marriage_date'];
        const fieldRestrictions = {
            person: {
                editable: ['name', 'sex', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service', 'attributes', 'parents'],
                uneditable: ['record_type'],
                greyedOut: ['gen', 'marriage_date', 'relationship', 'divorced', 'divorce date']
            },
            partner: {
                editable: ['name', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service', 'marriage_date', 'relationship', 'divorce', 'parents'],
                uneditable: ['record_type'],
                greyedOut: ['gen', 'sex']
            }
        };
        const DROPBOX_FOLDER = '';

        async function getAccessToken() {
            try {
                const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: DROPBOX_REFRESH_TOKEN,
                        client_id: DROPBOX_APP_KEY,
                        client_secret: DROPBOX_APP_SECRET
                    })
                });
                const data = await response.json();
                if (data.error) throw new Error(data.error_description || 'Failed to refresh access token');
                return data.access_token;
            } catch (err) {
                throw new Error('Unable to authenticate with Dropbox');
            }
        }

        function openStoryModal(personIndex = null, partnerIndex = null) {
            if (!records || records.length === 0) {
                safeShowError('No records loaded.');
                return;
            }

            safeOpenModal('story');
            document.getElementById('modalTitle').textContent = 'Edit Story';

            // Build list in tree order (same as records array)
            const allPeople = [];
            records.forEach((person, personIndex) => {
                // Main person
                allPeople.push({ 
                    label: person.name || '(no name)', 
                    personIndex, 
                    partnerIndex: null 
                });

                // Partners (sub-array)
                (person.partners || []).forEach((partner, partnerSubIndex) => {
                    allPeople.push({
                        label: `‚îî ${partner.name || '(unnamed)'}`,
                        personIndex,
                        partnerIndex: partnerSubIndex  // Correct sub-index within partners array
                    });
                });
            });

            if (debugMode) {
                console.log('--- STORY MODAL DROPDOWN BUILD DEBUG ---');
                allPeople.forEach((item, listPos) => {
                    const isPartner = item.partnerIndex !== null;
                    const targetRecord = isPartner 
                        ? records[item.personIndex]?.partners?.[item.partnerIndex]
                        : records[item.personIndex];

                    const storyValue = targetRecord?.story;
                    const hasStoryField = targetRecord?.hasOwnProperty('story');
                    const storyLength = typeof storyValue === 'string' ? storyValue.trim().length : 0;
                    const storyPreview = typeof storyValue === 'string' 
                        ? storyValue.trim().substring(0, 50) + (storyValue.trim().length > 50 ? '...' : '')
                        : '(missing or not string)';

                    const calculatedHasStory = storyLength > 0;

                    console.log(`List position ${listPos}: "${item.label}"`);
                    console.log(`  -> personIndex: ${item.personIndex}, partnerIndex: ${item.partnerIndex || 'null'}`);
                    console.log(`  -> target record exists: ${!!targetRecord}`);
                    console.log(`  -> story field exists: ${hasStoryField}`);
                    console.log(`  -> story length: ${storyLength}`);
                    console.log(`  -> story preview: "${storyPreview}"`);
                    console.log(`  -> calculated hasStory: ${calculatedHasStory}`);
                    console.log(`  ---`);
                });
                console.log('--- END DROPDOWN BUILD DEBUG ---');
            }

            let optionsHtml = '<option value="">-- Select Person or Partner --</option>';
            allPeople.forEach(item => {
                const hasStory = item.partnerIndex !== null
                    ? (records[item.personIndex]?.partners?.[item.partnerIndex]?.story || '').trim().length > 0
                    : (records[item.personIndex]?.story || '').trim().length > 0;

                const icon = hasStory ? 'üìñ' : 'üìï';
                const value = item.partnerIndex !== null ? `${item.personIndex}|${item.partnerIndex}` : `${item.personIndex}|`;
                const selected = (personIndex === item.personIndex && partnerIndex === item.partnerIndex) ? 'selected' : '';

                optionsHtml += `<option value="${value}" ${selected}>${item.label} ${icon}</option>`;
            });

            document.getElementById('modalForm').innerHTML = `
                <div style="margin-bottom:12px;">
                    <label>Select Person or Partner</label>
                    <select id="storyPersonSelect" style="width:100%;padding:10px;font-size:16px;">
                        ${optionsHtml}
                    </select>
                </div>
                <div style="margin-bottom:12px;">
                    <label>Story <span id="storyCounter" style="float:right;color:#666;font-size:14px;">0 words ‚Ä¢ 0 characters</span></label>
                    <textarea id="storyText" rows="24" placeholder="Write the life story here‚Ä¶"
                            style="width:100%;font-family:Georgia,serif;font-size:17px;line-height:1.6;padding:12px;border:1px solid #999;border-radius:6px;resize:vertical;"></textarea>
                </div>
                <div style="text-align:center;margin-top:12px;">
                    <button type="button" onclick="saveStoryFromModal()" style="padding:12px 24px;font-size:17px;background:#28a745;">Save Story</button>
                    <button type="button" onclick="copyStoryToClipboard()" style="margin:0 8px;padding:10px 18px;background:#007bff;">Copy</button>
                    <button type="button" onclick="clearStoryFromModal()" style="padding:10px 18px;background:#dc3545;">Clear</button>
                    <button type="button" onclick="closeModal()" style="margin-left:8px;padding:10px 18px;background:#666;">Cancel</button>
                </div>
            `;

            const select = document.getElementById('storyPersonSelect');
            const textarea = document.getElementById('storyText');
            const counter = document.getElementById('storyCounter');

            const updateCounter = () => {
                const text = textarea.value;
                const words = text.trim().split(/\s+/).filter(w => w.length > 0).length;
                const chars = text.length;
                counter.textContent = `${words} word${words===1?'':'s'} ‚Ä¢ ${chars} chars`;
            };

            const loadStory = () => {
                const parts = select.value.split('|');
                const idx = parseInt(parts[0]);
                const partnerIdx = parts[1] ? parseInt(parts[1]) : null;
                let story = '';
                if (partnerIdx !== null) {
                    story = records[idx].partners[partnerIdx]?.story || '';
                } else if (idx >= 0) {
                    story = records[idx].story || '';
                }
                textarea.value = story.trim();
                updateCounter();
            };

            select.addEventListener('change', loadStory);
            textarea.addEventListener('input', updateCounter);
            loadStory();

            window.saveStoryFromModal = () => {
                const parts = select.value.split('|');
                const idx = parseInt(parts[0]);
                const partnerIdx = parts[1] ? parseInt(parts[1]) : null;
                const story = textarea.value.trim();

                if (debugMode) {
                    console.log('--- STORY SAVE DEBUG ---');
                    console.log('Select value:', select.value);
                    console.log('Parsed idx:', idx, 'partnerIdx:', partnerIdx);
                    console.log('Story length:', story.length);
                    console.log('Story preview:', story.substring(0, 100) + (story.length > 100 ? '...' : ''));
                }

                let savedTo = null;

                if (partnerIdx !== null && !isNaN(partnerIdx)) {
                    if (records[idx] && records[idx].partners && records[idx].partners[partnerIdx]) {
                        records[idx].partners[partnerIdx].story = story;
                        savedTo = `partner ${partnerIdx} of person ${idx}`;
                        if (debugMode) console.log('Saved to partner record:', records[idx].partners[partnerIdx]);
                    }
                } else {
                    if (records[idx]) {
                        records[idx].story = story;
                        savedTo = `main person ${idx}`;
                        if (debugMode) console.log('Saved to main person record:', records[idx]);
                    }
                }

                if (debugMode) {
                    if (savedTo) {
                        console.log(`Story saved successfully to ${savedTo}`);
                    } else {
                        console.log('ERROR: Story save failed - invalid index or record not found');
                    }
                    console.log('--- END STORY SAVE DEBUG ---');
                }

                safeCloseModal();
                displayRecords();  // Force immediate redraw to update book icon
            };

            window.clearStoryFromModal = () => {
                if (confirm('Permanently delete this story?')) {
                    textarea.value = '';
                    saveStoryFromModal();
                }
            };
        }

        function copyStoryToClipboard() {
            const txt = document.getElementById('storyText');
            txt.select();
            document.execCommand('copy');
            const btn = event.target;
            const old = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.background = '#218838';
            setTimeout(() => {
                btn.textContent = old;
                btn.style.background = '#007bff';
            }, 1500);
        }

        function saveStory(personIndex, partnerIndex = null) {
            const story = document.getElementById('storyText').value;

            if (partnerIndex !== null) {
                const person = records[personIndex];
                if (person && person.partners && person.partners[partnerIndex]) {
                    person.partners[partnerIndex].story = story;
                }
            } else {
                if (records[personIndex]) {
                    records[personIndex].story = story;
                }
            }
            safeCloseModal();
            debounceDisplayRecords();
        }

        function clearStoryConfirm(personIndex, partnerRecordId = null) {
            if (confirm('Permanently delete this entire story? This cannot be undone.')) {
                document.getElementById('storyText').value = '';
                saveStory(personIndex, partnerRecordId);
            }
        }       

        function safeOpenModal(mode) {
            if (window.location.search && !window.location.search.includes('debug=1'))
                window.history.replaceState({}, document.title, window.location.pathname);
            modalMode = mode;
            document.getElementById('modal').style.display = 'block';
            document.getElementById('modalForm').innerHTML = '';
        }

        function safeCloseModal() {
            document.getElementById('modal').style.display = 'none';
            modalMode = null;
            document.getElementById('modalForm').innerHTML = '';
        }

        function safeShowError(message) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:20px;right:20px;background:#dc3545;color:white;padding:15px;border-radius:5px;z-index:2000;max-width:300px;box-shadow:0 2px 10px rgba(0,0,0,0.2);font-size:14px';
            div.innerHTML = `<strong>Error</strong><br>${message}<button onclick="this.parentElement.remove()" style="margin-left:10px;background:none;border:none;color:white;cursor:pointer;float:right">√ó</button>`;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 6000);
        }

        function showPopup(html, autoCloseMs = 4000) {
            const div = document.createElement('div');
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border:1px solid #000;z-index:10000;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.3);max-width:90%;text-align:center;';
            div.innerHTML = html + '<br><button onclick="this.parentElement.remove()" style="margin-top:15px;padding:8px 16px;cursor:pointer;">Close</button>';
            document.body.appendChild(div);

            // Auto-close after specified time (unless 0 or negative)
            if (autoCloseMs > 0) {
                setTimeout(() => {
                    if (div.parentElement) div.remove();
                }, autoCloseMs);
            }
        }

        // ==================== PROVIDE FEEDBACK ====================
        function openFeedbackModal() {
            safeOpenModal('feedback');
            document.getElementById('modalTitle').textContent = 'Provide Feedback';
            document.getElementById('modalForm').innerHTML = `
                <label>Feedback Title <span style="color:red">*</span></label>
                <input type="text" id="feedbackTitle" required>

                <label>Description <span style="color:red">*</span></label>
                <textarea id="feedbackDesc" rows="6" required></textarea>

                <button type="button" onclick="submitFeedback()">Submit Feedback</button>
            `;
        }

        async function submitFeedback() {
            const title = document.getElementById('feedbackTitle').value.trim();
            const desc = document.getElementById('feedbackDesc').value.trim();
            if (!title || !desc) {
                safeShowError('Both title and description are required');
                return;
            }

            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;

            const data = {
                timestamp: `${year}-${month}-${day} ${hours}:${minutes}:${seconds} PST`,
                ticket_number: ticketNumber || "none",
                feedback_title: title,
                feedback_description: desc
            };

            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const filename = `feedback/feedback_${timestamp}_${ticketNumber || 'none'}.json`;

                await dbx.filesUpload({
                    contents: JSON.stringify(data, null, 2),
                    path: DROPBOX_FOLDER + '/' + filename,
                    mode: { '.tag': 'add' },
                    autorename: true
                });

                safeCloseModal();
                showPopup(`
                    <h3 style="color:green">‚úì Feedback Submitted</h3>
                    <p>Thank you! Your feedback has been saved as:</p>
                    <b>${filename}</b>
                    <p>We appreciate your input.</p>
                `);
            } catch (err) {
                safeShowError('Failed to submit feedback: ' + err.message);
            }
        }

        async function loadFromDropbox() {
            if (debugMode) {
                document.getElementById('textFile').click();
                return;
            }

            const passphrase = await askPassphrase('File Retrieval');
            if (!passphrase) return;
            exchangePassphrase = passphrase;
            decryptionPassphrase = passphrase;

            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const fileHash = CryptoJS.SHA256(passphrase).toString();
                const response = await dbx.filesListFolder({ path: DROPBOX_FOLDER });
                const fileEntry = response.result.entries
                    .filter(e => e.name.startsWith(fileHash) && e.name.endsWith('.zip'))
                    .sort((a, b) => b.name.localeCompare(a.name))[0];
                if (!fileEntry) {
                    safeShowError('No file found in Dropbox for the provided passphrase.');
                    return;
                }

                const fileResponse = await dbx.filesDownload({ path: fileEntry.path_display });
                const buffer = await fileResponse.result.fileBlob.arrayBuffer();
                const plainZip = decryptBlob(buffer, passphrase);
                const zip = await JSZip.loadAsync(plainZip);

                const jsonEntry = Object.values(zip.files).find(f => f.name.match(/records_?\d*\.json$/i));
                if (!jsonEntry) throw new Error('No records_<ticket>.json found in ZIP');

                originalFileName = jsonEntry.name.replace(/\.json$/i, '.zip');
                ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Unknown';

                document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Loaded`;

                const text = await jsonEntry.async('text');
                const obj = JSON.parse(text);

                let recordArray;
                if (obj.data && Array.isArray(obj.data)) {
                    recordArray = obj.data;
                } else if (obj.records && Array.isArray(obj.records)) {
                    recordArray = obj.records;
                } else {
                    throw new Error('No valid record array found in downloaded JSON');
                }

                records = recordArray;

                // Normalize: ensure partners is array, even if empty
                records.forEach(r => {
                    if (!Array.isArray(r.partners)) r.partners = [];
                    if (!r.parent_ids) r.parent_ids = [];
                    if (!r.children_no_other_parent) r.children_no_other_parent = [];
                    if (!r.notes) r.notes = [];
                    if (!r.unprocessed_items) r.unprocessed_items = [];
                });

                isEncryptedZip = true;
                finishLoad();
            } catch (err) {
                safeShowError(`Failed to load from Dropbox: ${err.message}`);
                resetSession();
            }
        }
        
        function askPassphrase(promptText) {
            return new Promise(resolve => {
                // Defer execution until next tick ‚Äî ensures safeOpenModal exists
                setTimeout(() => {
                    safeOpenModal('passphrase');
                    document.getElementById('modalTitle').textContent = `Enter Passphrase for ${promptText}`;
                    document.getElementById('modalForm').innerHTML = `
                        <label>Passphrase</label>
                        <input type="password" id="pp" autocomplete="off" data-lpignore="true" autofocus>
                        <button type="button" onclick="window.resolvePass()">Submit</button>
                    `;
                    window.resolvePass = () => {
                        const val = document.getElementById('pp').value;
                        safeCloseModal();
                        resolve(val || null);
                    };
                }, 0);
            });
        }

        function resetSession() {
            records = [];
            decryptionPassphrase = null;
            exchangePassphrase = null;
            originalFileName = 'records.zip';
            ticketNumber = null;
            isEncryptedZip = false;
            hasReturnedUpdates = false;
            document.getElementById('selectLoadBtn').style.display = 'block';
            document.getElementById('requestEditBtn').style.display = 'block';
            ['addChildBtn','addPartnerBtn','updateRecordBtn','recordDeathBurialBtn','viewTableBtn','editStoryBtn','returnUpdatesBtn','exitBtn'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById('fileStatus').textContent = 'No records loaded';
            document.getElementById('tableContainer').style.display = 'none';
            document.getElementById('recordBody').innerHTML = '';
        }

        function enableButtonsAfterLoad() {
            document.getElementById('selectLoadBtn').style.display = 'none';
            document.getElementById('requestEditBtn').style.display = 'none';
            ['addParentBtn','addChildBtn','addPartnerBtn','updateRecordBtn','editStoryBtn','recordDeathBurialBtn','viewTableBtn','returnUpdatesBtn'].forEach(id => {
                document.getElementById(id).style.display = 'block';
                document.getElementById(id).classList.remove('disabled-btn');
            });
            
        }

        function finishLoad() {
            enableButtonsAfterLoad();
            debounceDisplayRecords();
        }

        function exitApp() {
        if (confirm("Are you sure you want to exit? Any unsaved changes will be lost.")) {
            // Fully clear sensitive data from memory
            records.length = 0;                // Clear the array contents
            records = [];                      // Replace with new empty array
            
            decryptionPassphrase = null;
            exchangePassphrase = null;
            originalHeader = {};
            ticketNumber = null;
            editingPartnerId = null;
            
            // Force garbage collection of any lingering references
            if (window.gc && debugMode) window.gc();

            resetSession();
        }
    }

        function openRequestModal() {
            safeOpenModal('requestEdit');
            document.getElementById('modalTitle').textContent = 'Request New Edit Package';
            document.getElementById('modalForm').innerHTML = `
                <label>Your Full Name <span style="color:red">*</span></label>
                <input type="text" required>
                <label>Your Email <span style="color:red">*</span></label>
                <input type="email" required>
                <label>Starting Person Full Name (exactly as in the tree) <span style="color:red">*</span></label>
                <input type="text" required>
                <label>Starting Person Birth Year (e.g. 1946) <span style="color:red">*</span></label>
                <input type="text" pattern="[0-9]{4}" placeholder="e.g. 1946" required>
                <label>Your Relationship to This Person (e.g. grandson, niece, self) <span style="color:red">*</span></label>
                <input type="text" required>
                <div class="note">
                    An acknowledgement email containing a passphrase will be sent to the email address above.
                </div>
                <button type="button" onclick="submitEditRequest()">Submit Request</button>
            `;
        }

        async function submitEditRequest() {
            const inputs = document.querySelectorAll('#modalForm input');
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const tz = now.toLocaleTimeString('en-us', { timeZoneName: 'short' }).split(' ')[2];
            const formattedTimestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${tz}`;
            const data = {
                timestamp: formattedTimestamp,
                requestor_name: inputs[0].value.trim(),
                requestor_email: inputs[1].value.trim(),
                starting_person: inputs[2].value.trim(),
                starting_person_birth_year: inputs[3].value.trim(),
                relationship: inputs[4].value.trim()
            };
            if (Object.values(data).some(v => v === '')) {
                safeShowError('Please fill in all required fields.');
                return;
            }
            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const datePart = now.toISOString().slice(0,10).replace(/-/g,'');
                const timePart = now.toTimeString().slice(0,8).replace(/:/g,'');
                const safeName = data.requestor_name.replace(/[^a-zA-Z0-9]/g, '_').slice(0,20);
                const filename = `requests/request_${datePart}_${timePart}_${safeName}.json`;
                await dbx.filesUpload({
                    contents: JSON.stringify(data, null, 2),
                    path: DROPBOX_FOLDER + '/' + filename,
                    mode: { '.tag': 'add' },
                    autorename: true
                });
                safeCloseModal();
                showPopup(`
                    <h3 style="color:green">‚úì Request Submitted Successfully!</h3>
                    <p><strong>Request Time:</strong> ${formattedTimestamp}</p>
                    <p>Your request has been saved as:<br><b>${filename}</b></p>
                    <p>I will prepare your edit package and send you a passphrase by email shortly.</p>
                `);
            } catch (err) {
                safeShowError('Failed to submit request: ' + err.message);
            }
        }

        function deriveKey(passphrase, salt) {
            return CryptoJS.PBKDF2(passphrase, salt, { keySize: 8, iterations: 100000, hasher: CryptoJS.algo.SHA256 });
        }

        function decryptBlob(arrayBuffer, passphrase) {
            const data = new Uint8Array(arrayBuffer);
            if (data.length < 32) throw new Error("File too short");
            const salt = CryptoJS.lib.WordArray.create(data.slice(0, 16));
            const iv = CryptoJS.lib.WordArray.create(data.slice(16, 32));
            const ct = CryptoJS.lib.WordArray.create(data.slice(32));
            const key = deriveKey(passphrase, salt);
            const decrypted = CryptoJS.AES.decrypt({ ciphertext: ct }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
            const decryptedBytes = CryptoJS.enc.Latin1.stringify(decrypted);
            const padLen = decryptedBytes.charCodeAt(decryptedBytes.length - 1);
            if (padLen < 1 || padLen > 16) throw new Error("Invalid padding");
            return decryptedBytes.slice(0, -padLen);
        }

        function encryptBlob(zipBinaryString, passphrase) {
            const salt = CryptoJS.lib.WordArray.random(16);
            const iv = CryptoJS.lib.WordArray.random(16);
            const key = deriveKey(passphrase, salt);
            const len = zipBinaryString.length;
            const padLen = 16 - (len % 16);
            let padded = zipBinaryString;
            for (let i = 0; i < padLen; i++) padded += String.fromCharCode(padLen);
            const wordArray = CryptoJS.enc.Latin1.parse(padded);
            const encrypted = CryptoJS.AES.encrypt(wordArray, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
            return salt.concat(iv).concat(encrypted.ciphertext);
        }

        async function downloadUpdates() {
            if (!records.length) return safeShowError('No data to save');
            if (!exchangePassphrase && isEncryptedZip) return safeShowError('Exchange passphrase required');
            let blob;

            if (debugMode && !isEncryptedZip) {
                // Build full JSON with preserved header + new metadata
                const now = new Date();
                const iso = now.toISOString().replace(/T/, ' ').replace(/\..+/, '');

                const output = {
                    ...originalHeader,                                   // keep everything from original file
                    editor: "Genealogy Recorder Web Editor",
                    editor_version: document.getElementById('pageVersion').textContent.trim(),
                    last_edited: iso + " UTC",
                    data: records                                        // current data
                };

                const jsonContent = JSON.stringify(output, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `edited_${originalFileName.replace(/\.zip$/i, '.json')}`;
                a.click();
                URL.revokeObjectURL(url);

                showPopup(`<h3 style="color:green">JSON Saved Locally</h3><p>edited_${originalFileName.replace(/\.zip$/i, '.json')}</p) <small>Includes header & editor info</small>`);
                hasReturnedUpdates = true;
                document.getElementById('exitBtn').style.display = 'block';
                return;
            }

            // Normal flow: create encrypted ZIP with full JSON (header + metadata + data)
                const now = new Date();
                const iso = now.toISOString().replace(/T/, ' ').replace(/\..+/, '');

                const fullOutput = {
                    ...originalHeader,
                    editor: "Genealogy Recorder Web Editor",
                    editor_version: document.getElementById('pageVersion').textContent.trim(),
                    last_edited: iso + " UTC",
                    data: records
                };

                const jsonContent = JSON.stringify(getOutputObject(fullOutput), null, 2);

                const zip = new JSZip();
                zip.file(`records_${ticketNumber}.json`, jsonContent);
                const zipBin = await zip.generateAsync({ type: 'uint8array' });
                const encrypted = encryptBlob(String.fromCharCode.apply(null, zipBin), decryptionPassphrase || exchangePassphrase);
                const uint8 = new Uint8Array(encrypted.sigBytes);
                for (let i = 0; i < encrypted.sigBytes; i++) {
                    const w = encrypted.words[Math.floor(i / 4)];
                    uint8[i] = (w >>> (24 - (i % 4) * 8)) & 0xFF;
                }
                blob = new Blob([uint8], { type: 'application/octet-stream' });

            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const fileHash = CryptoJS.SHA256(exchangePassphrase).toString();
                const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
                const dropboxPath = `${DROPBOX_FOLDER}/${fileHash}_edited_${timestamp}.zip`;

                await dbx.filesUpload({ contents: blob, path: dropboxPath, mode: 'overwrite' });

                showPopup(`Updated file saved to Dropbox as edited_${timestamp}.zip`);
                hasReturnedUpdates = true;
                document.getElementById('exitBtn').style.display = 'block';
                document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Returned`;
            } catch (err) {
                safeShowError(`Failed to upload: ${err.message}`);
            }
        }

    function handleFileSelect() {
            const file = document.getElementById('textFile').files[0];
            if (!file) return;
        
            const reader = new FileReader();
        
            if (file.name.endsWith('.json')) {
                reader.onload = function(e) {
                    try {
                        const fullObj = JSON.parse(e.target.result);
        
                        // Preserve everything that is NOT the data array as header
                        originalHeader = { ...fullObj };
                        delete originalHeader.data;
                        delete originalHeader.records;   // in case older format used "records"
        
                        // Extract the actual array
                        let recordArray;
                        if (fullObj.data && Array.isArray(fullObj.data)) {
                            recordArray = fullObj.data;
                        } else if (fullObj.records && Array.isArray(fullObj.records)) {
                            recordArray = fullObj.records;
                        } else if (Array.isArray(fullObj)) {
                            recordArray = fullObj;
                        } else {
                            throw new Error('JSON does not contain a recognizable record array');
                        }
        
                        records = recordArray;
        
                        // Normalise fields
                        records.forEach(r => {
                            if (!Array.isArray(r.partners)) r.partners = [];
                            if (!r.parent_ids) r.parent_ids = [];
                            if (!r.children_no_other_parent) r.children_no_other_parent = [];
                            if (!r.notes) r.notes = [];
                            if (!r.unprocessed_items) r.unprocessed_items = [];
                        });
        
                        originalFileName = file.name.replace(/\.json$/i, '.zip');
                        ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Local';
                        document.getElementById('fileStatus').textContent = `Local JSON Loaded ‚Äì ${file.name}`;
                        finishLoad();
                    } catch (err) {
                        safeShowError('Invalid JSON file: ' + err.message);
                        console.error('JSON parse error:', err);
                    }
                };
                reader.readAsText(file);
                return;
            }

            // === ZIP handling (encrypted) ===
            if (file.name.endsWith('.zip')) {
                reader.onload = async function(e) {
                    try {
                        const buffer = e.target.result;
                        const passphrase = await askPassphrase('Decrypt Local ZIP');
                        if (!passphrase) return;

                        const plainZip = decryptBlob(buffer, passphrase);
                        const zip = await JSZip.loadAsync(plainZip);

                        const jsonEntry = Object.values(zip.files).find(f => f.name.match(/records_?\d*\.json$/i));
                        if (!jsonEntry) throw new Error('No records_<ticket>.json found in ZIP');

                        originalFileName = jsonEntry.name.replace(/\.json$/i, '.zip');
                        ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Local';
                        document.getElementById('fileStatus').textContent = `Local ZIP Loaded ‚Äì Ticket ${ticketNumber}`;

                        const text = await jsonEntry.async('text');
                        const obj = JSON.parse(text);

                        let recordArray;
                        if (obj.data && Array.isArray(obj.data)) {
                            recordArray = obj.data;
                        } else if (obj.records && Array.isArray(obj.records)) {
                            recordArray = obj.records;
                        } else {
                            throw new Error('No valid record array found in downloaded JSON');
                        }

                        records = recordArray;
                        records.forEach(r => {
                            if (!Array.isArray(r.partners)) r.partners = [];
                            if (!r.parent_ids) r.parent_ids = [];
                            if (!r.children_no_other_parent) r.children_no_other_parent = [];
                            if (!r.notes) r.notes = [];
                            if (!r.unprocessed_items) r.unprocessed_items = [];
                        });

                        isEncryptedZip = true;
                        decryptionPassphrase = passphrase;
                        exchangePassphrase = passphrase;
                        finishLoad();
                    } catch (err) {
                        safeShowError('Failed to load ZIP: ' + err.message);
                    }
                };
                reader.readAsArrayBuffer(file);
                return;
            }

            safeShowError('Please select a .json or encrypted .zip file');
        }

        function dateToTimestamp(dateStr) {
            if (!dateStr) return Infinity;
            const parts = dateStr.split('-').map(Number);
            if (parts.length === 1) return parts[0] * 10000 * 100;
            if (parts.length === 2) return parts[0] * 10000 * 100 + parts[1] * 100;
            return parts[0] * 10000 * 100 + parts[1] * 100 + parts[2];
        }
        window.addEventListener('beforeunload', e => {
            if (modalMode) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        window.addEventListener('error', e => {
            if (e.message.includes('runtime.lastError')) {
                e.preventDefault();
                return false;
            }
        });
        function isValidDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return true;
            const parts = dateStr.split('-');
            if (parts.length === 1) {
                const year = parseInt(parts[0], 10);
                return !isNaN(year) && year >= 1 && year <= 9999;
            } else if (parts.length === 2) {
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                return !isNaN(year) && year >= 1 && year <= 9999 && !isNaN(month) && month >= 1 && month <= 12;
            } else if (parts.length === 3) {
                const date = Date.parse(dateStr + 'T00:00:00');
                if (isNaN(date)) return false;
                const parsedDate = new Date(date);
                return parsedDate.getFullYear() == parts[0] && (parsedDate.getMonth() + 1) == parts[1] && parsedDate.getDate() == parts[2];
            }
            return false;
        }

        function openModal(mode) {
            safeOpenModal(mode);
            const modalTitle = document.getElementById('modalTitle');
            const modalForm = document.getElementById('modalForm');
            let fields = [];
            if (mode === 'addChild') {
                modalTitle.textContent = 'Add Child';
                const selectablePeople = records;  // All top-level records are main persons ‚Äî no record_type needed
                fields = [
                    { name: 'parents', label: 'Genealogical Parent Name', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'sex', label: 'Sex', type: 'select', options: ['', 'male', 'female'] },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' }
                ];
            } else if (mode === 'addPartner') {
                modalTitle.textContent = 'Add Partner';
                const selectablePeople = records;  // All top-level records are main persons ‚Äî no record_type needed
                fields = [
                    { name: 'partner', label: 'Select Genealogical Partner', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'relationship', label: 'Relationship', type: 'select', options: ['', 'spouse', 'partner', 'other'], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' },
                    { name: 'marriage_date', label: 'Marriage Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'parents', label: 'Parents', type: 'text', autocomplete: 'off' }
                ];
            } else if (mode === 'addParent') {
                modalTitle.textContent = 'Add Parent (Genealogical Ancestor)';
                fields = [
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'sex', label: 'Sex', type: 'select', options: ['', 'male', 'female'] },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' },
                    { name: 'death_date', label: 'Death Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'death_location', label: 'Death Location', type: 'text' },
                    { name: 'burial_location', label: 'Burial Location', type: 'text' },
                    { name: 'service', label: 'Service (e.g. military)', type: 'text' },
                    { name: 'parents', label: 'Parents', type: 'text', autocomplete: 'off' },
                    { name: 'new_root_gen', label: 'New Root Generation', type: 'text', value: '1', required: true }
                ];

                // Add explanatory note (same way other modes do if needed)
                setTimeout(() => {
                    const note = document.createElement('p');
                    note.className = 'note';
                    note.innerHTML = 'This adds a parent above the current root person.<br>Use only when extending upward in a new branch.<br>Spouses must be added using "Add Partner".';
                    const form = document.getElementById('modalForm');
                    if (form.firstChild) {
                        form.insertBefore(note, form.firstChild);
                    } else {
                        form.appendChild(note);
                    }
                }, 0);
            
            } else if (mode === 'updateRecord') {
                modalTitle.textContent = 'Update Record';
                const recordOptions = records.flatMap((person, i) => {
                    const main = person.name || '(no name)';
                    const partners = (person.partners || []).map(p => `Partner: ${p.name || '(no name)'}`);
                    return [main, ...partners];
                });
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...recordOptions], required: true },
                    { name: 'field', label: 'Field to Update', type: 'select', options: [''] },
                    { name: 'value', label: 'New Value', type: 'text', required: true }
                ];
            } else if (mode === 'recordDeathBurial') {
                modalTitle.textContent = 'Record Death/Burial';
                const recordOptions = records.flatMap((person, i) => {
                    const main = person.name || '(no name)';
                    const partners = (person.partners || []).map(p => `Partner: ${p.name || '(no name)'}`);
                    return [main, ...partners];
                });
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...recordOptions], required: true },
                    { name: 'death_date', label: 'Death Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'death_location', label: 'Death Location', type: 'text' },
                    { name: 'burial_location', label: 'Burial Location', type: 'text' }
                ];
            }
            fields.forEach(field => {
                const label = document.createElement('label');
                label.textContent = field.label;
                if (field.required) label.innerHTML += ' <span style="color:red">*</span>';
                modalForm.appendChild(label);
                if (field.type === 'select') {
                    const select = document.createElement('select');
                    select.name = field.name;
                    if (field.required) select.required = true;
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt || '(Select)';
                        select.appendChild(option);
                    });
                    modalForm.appendChild(select);
                } else {
                    const input = document.createElement(field.type === 'textarea' ? 'textarea' : 'input');
                    input.type = field.type;
                    input.name = field.name;
                    if (field.required) input.required = true;
                    if (field.autocomplete) input.setAttribute('autocomplete', field.autocomplete);
                    modalForm.appendChild(input);
                }
            });
            const submitBtn = document.createElement('button');
            submitBtn.type = 'button';
            submitBtn.textContent = 'Save';
            submitBtn.onclick = () => {
                if (submitBtn.disabled) return;
                submitBtn.disabled = true;
                setTimeout(() => submitBtn.disabled = false, 1000);
                saveModalData(mode);
            };
            modalForm.appendChild(submitBtn);
            if (mode === 'updateRecord') {
                const recordSelect = modalForm.querySelector('select[name="record"]');
                const fieldSelect = modalForm.querySelector('select[name="field"]');
                recordSelect.addEventListener('change', () => {
                    const selectedRecord = recordSelect.value;
                    if (!selectedRecord) {
                        fieldSelect.innerHTML = '<option value=""></option>';
                        return;
                    }
                    const [recordType, name] = selectedRecord.split(': ');
                    const cleanType = recordType.toLowerCase() === 'partner' ? 'partner' : 'person';
                    const editableFields = [...fieldRestrictions[cleanType].editable];
                    fieldSelect.innerHTML = '';
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    fieldSelect.appendChild(emptyOption);
                    editableFields.forEach(f => {
                        const option = document.createElement('option');
                        option.value = f;
                        option.textContent = f;
                        fieldSelect.appendChild(option);
                    });
                    fieldSelect.value = '';
                    fieldSelect.addEventListener('change', () => {
                        const valueInput = modalForm.querySelector('[name="value"]');
                        if (fieldSelect.value === 'attributes' && cleanType === 'person') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'stillborn', 'step', 'foster', 'adopted', 'continuation'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(None)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (fieldSelect.value === 'sex' && cleanType === 'person') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'male', 'female'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(Select)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (fieldSelect.value === 'relationship' && cleanType === 'spouse') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'spouse', 'partner', 'other'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(Select)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (valueInput.tagName === 'SELECT') {
                            const newInput = document.createElement('input');
                            newInput.type = 'text';
                            newInput.name = 'value';
                            newInput.required = true;
                            valueInput.replaceWith(newInput);
                        }
                    });
                });
            }
        }
        function closeModal() { safeCloseModal(); }

        function shiftAllGenerations(newRootGen) {
            const currentGens = records.map(r => parseInt(r.generation || 9999));
            const currentMin = Math.min(...currentGens);
            const delta = currentMin - newRootGen;

            records.forEach(r => {
                if (r.generation !== undefined) {
                    r.generation = (parseInt(r.generation) - delta).toString();
                }
            });
        }

        function saveModalData(mode) {
            try {
                const form = document.getElementById('modalForm');
                const data = {};
                for (let input of form.elements) {
                    if (input.name && input.type !== 'button') data[input.name] = input.value || '';
                }
                if (debugMode) console.log(`Processing ${mode} with data:`, data);
                if (mode === 'addChild') {
                    if (!data.name || !data.parents) { safeShowError('Name and Parent are required.'); return; }
                    if (data.birth_date && !isValidDate(data.birth_date)) { safeShowError('Invalid birth date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }

                    console.log('DEBUG ADD CHILD: Expected parent name = "' + data.parents + '"');
                    console.log('DEBUG ADD CHILD: Expected length = ' + data.parents.length);
                    console.log('DEBUG ADD CHILD: Expected repr = ' + JSON.stringify(data.parents));  // shows hidden chars

                    let foundParent = null;
                    for (let i = 0; i < records.length; i++) {
                        const r = records[i];
                        const rName = r.name || '(no name)';
                        const rType = r.record_type;
                        const nameMatch = rName === data.parents;
                        let typeMatch = false;
                        let typeError = null;
                        if (rType === undefined) {
                            typeError = 'record_type is undefined';
                        } else {
                            try {
                                typeMatch = rType.toLowerCase() === 'person';
                            } catch (e) {
                                typeError = 'Exception on toLowerCase: ' + e.message;
                            }
                        }
                        const fullMatch = nameMatch && typeMatch;

                        console.log(`DEBUG ADD CHILD: Checking index ${i}: name="${rName}" (length ${rName.length}), record_type=${rType}`);
                        console.log(`  nameMatch: ${nameMatch} | typeMatch: ${typeMatch} | fullMatch: ${fullMatch} | typeError: ${typeError || 'none'}`);

                        if (fullMatch) {
                            foundParent = r;
                            console.log(`DEBUG ADD CHILD: MATCH FOUND at index ${i}`);
                            break;
                        }
                        if (typeError) {
                            console.log(`DEBUG ADD CHILD: STOPPING DEBUG - would crash here on typeError`);
                        }
                    }

                    if (!foundParent) {
                        safeShowError('Invalid parent selected - no matching Person record found (check console for debug details).');
                        return;
                    }

                    const parent = foundParent;
                    
                    if (!parent) { safeShowError('Invalid parent selected.'); return; }
                    if (data.birth_date && !isValidDate(data.birth_date)) { safeShowError('Invalid birth date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    const parentGeneration = parseInt(parent.generation) || 0;
                    const newRecord = {
                        record_type: 'Person',
                        generation: (parentGeneration + 1).toString(),
                        name: data.name,
                        sex: data.sex || '',
                        birth_date: data.birth_date || '',
                        birth_location: data.birth_location || '',
                        parents: '',
                        death_date: '',
                        death_location: '',
                        burial_location: '',
                        service: '',
                        marriage_date: '',
                        relationship: '',
                        divorce: '',
                        attributes: '',
                        unprocessed_items: '',
                        notes: ''
                    };
                    let insertIndex = records.indexOf(parent) + 1;
                    let treeEnd = records.length;
                    for (let i = insertIndex; i < records.length; i++) {
                        if (records[i].record_type.toLowerCase() === 'person' && (parseInt(records[i].generation) || 0) <= parentGeneration) {
                            treeEnd = i;
                            break;
                        }
                    }
                    if (debugMode) console.log(`Parent ${parent.name} (gen: ${parentGeneration}) descendant tree ends at index ${treeEnd}`);
                    const children = records.slice(insertIndex, treeEnd).filter(r => r.record_type.toLowerCase() == 'person' && (parseInt(r.generation) || 0) === parentGeneration + 1);
                    if (debugMode) console.log(`Found ${children.length} children for parent ${parent.name}`);
                    if (children.length > 0 && data.birth_date) {
                        const newTimestamp = dateToTimestamp(data.birth_date);
                        if (debugMode) console.log(`New child birth_date: ${data.birth_date}, timestamp: ${newTimestamp}`);
                        const sortedChildren = records.slice(insertIndex, treeEnd)
                            .reduce((acc, r, i) => r.record_type.toLowerCase() === 'person' && (parseInt(r.generation) || 0) === parentGeneration + 1 ? [...acc, { index: i + insertIndex, ts: dateToTimestamp(r.birth_date) }] : acc, [])
                            .sort((a, b) => a.ts - b.ts);
                        if (debugMode) console.log(`Sorted children:`, sortedChildren);
                        const insertPos = sortedChildren.findIndex(c => c.ts > newTimestamp);
                        insertIndex = insertPos === -1 ? treeEnd : sortedChildren[insertPos].index;
                        if (debugMode) console.log(`Inserting child at index ${insertIndex}`);
                    } else {
                        insertIndex = treeEnd;
                        if (debugMode) console.log(`No children or no birth_date, inserting at index ${insertIndex}`);
                    }
                    records.splice(insertIndex, 0, newRecord);
                    if (debugMode) console.log('Added child record:', newRecord, `at index ${insertIndex}`);
                } else if (mode === 'addPartner') {
                    if (!data.name || !data.partner || !data.relationship) { 
                        safeShowError('Name, Select Genealogical Partner, and Relationship are required.'); 
                        return; 
                    }

                    // Find the selected main person by name
                    const mainPerson = records.find(r => r.name === data.partner);
                    if (!mainPerson) { 
                        safeShowError('Selected genealogical partner not found.'); 
                        return; 
                    }

                    if (data.birth_date && !isValidDate(data.birth_date)) { 
                        safeShowError('Invalid birth date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); 
                        return; 
                    }
                    if (data.marriage_date && !isValidDate(data.marriage_date)) { 
                        safeShowError('Invalid marriage date. Use YYYY-MM-DD, YYYY-MM or YYYY.'); 
                        return; 
                    }

                    // Create partner object (nested)
                    const newPartner = {
                        name: data.name.trim(),
                        relationship: data.relationship,
                        birth_date: data.birth_date || '',
                        birth_location: data.birth_location || '',
                        death_date: data.death_date || '',
                        death_location: data.death_location || '',
                        burial_location: data.burial_location || '',
                        service: data.service || '',
                        marriage_date: data.marriage_date || '',
                        divorce: data.divorce || '',
                        divorce_date: data.divorce_date || '',
                        parents: data.parents || '',
                        story: '',
                        photos: []
                    };

                    // Ensure partners array exists
                    if (!Array.isArray(mainPerson.partners)) {
                        mainPerson.partners = [];
                    }

                    // Insert into partners array (marriage date sorting optional ‚Äî can add later)
                    mainPerson.partners.push(newPartner);

                    // Optional: sort partners by marriage_date if present
                    if (data.marriage_date) {
                        mainPerson.partners.sort((a, b) => {
                            const aTs = dateToTimestamp(a.marriage_date || '');
                            const bTs = dateToTimestamp(b.marriage_date || '');
                            return aTs - bTs;
                        });
                    }
                
                } else if (mode === 'updateRecord') {
                    if (!data.record || !data.field) { safeShowError('Please select a record and field.'); return; }
                    if (!data.value && data.field !== 'attributes' && data.field !== 'sex') { safeShowError('Please enter a value.'); return; }
                    const [recordType, name] = data.record.split(': ');
                    const record = records.find(r => (r.record_type.toLowerCase() === 'partner' ? 'Partner' : r.record_type) === recordType && r.name === name);
                    if (!record) { safeShowError('Invalid record selected.'); return; }
                    if (data.field === 'relationship' && !['', 'spouse', 'partner', 'other'].includes(data.value)) { safeShowError('Relationship must be "spouse", "partner", or "other".'); return; }
                    if (data.field === 'attributes' && !['', 'stillborn', 'step', 'foster', 'adopted', 'continuation'].includes(data.value)) { safeShowError('Attributes must be one of: None, stillborn, step, foster, adopted, continuation.'); return; }
                    if (data.field === 'sex' && !['', 'male', 'female'].includes(data.value)) { safeShowError('Sex must be one of: male, female, or empty.'); return; }
                    if (data.field === 'divorce' && data.value && data.value !== 'true' && !isValidDate(data.value)) { safeShowError('Divorce must be a valid date, "true", or empty.'); return; }
                    if (dateFields.includes(data.field) && data.value && !isValidDate(data.value)) { safeShowError('Invalid date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    const cleanType = recordType.toLowerCase() === 'partner' ? 'partner' : 'person';
                    const isEditable = fieldRestrictions[cleanType].editable.includes(data.field);
                    if (isEditable) {
                        const oldValue = record[data.field];
                        record[data.field] = data.value;
                        if (debugMode) console.log(`Updated ${data.field} from "${oldValue}" to "${data.value}" for ${name}`);
                    } else {
                        safeShowError('Selected field is not editable.');
                        return;
                    }
                } else if (mode === 'recordDeathBurial') {
                    if (!data.record) { safeShowError('Please select a record.'); return; }
                    const [recordType, name] = data.record.split(': ');
                    const record = records.find(r => (r.record_type.toLowerCase() === 'partner' ? 'Partner' : r.record_type) === recordType && r.name === name);
                    if (!record) { safeShowError('Invalid record selected.'); return; }
                    if (data.death_date && !isValidDate(data.death_date)) { safeShowError('Invalid death date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    let updated = false;
                    if (data.death_date && isFieldEditable(record.record_type, 'death_date')) { record.death_date = data.death_date; updated = true; }
                    if (data.death_location && isFieldEditable(record.record_type, 'death_location')) { record.death_location = data.death_location; updated = true; }
                    if (data.burial_location && isFieldEditable(record.record_type, 'burial_location')) { record.burial_location = data.burial_location; updated = true; }
                    if (!updated) { safeShowError('At least one field (Death Date, Death Location, or Burial Location) must be provided and editable.'); return; }
                    if (debugMode) console.log(`Updated death/burial info for ${name}`);
                
                } else if (mode === 'addParent') {
                    if (!data.name) return safeShowError('Name is required.');

                    const newRootGen = parseInt(data.new_root_gen) || 1;
                    if (isNaN(newRootGen) || newRootGen < 1) return safeShowError('Generation must be ‚â•1');

                    // Pre-edit root gen = current root gen - 1 (adding a parent one generation earlier)
                    const currentRootGen = records.length > 0 ? parseInt(records[0].generation || 1) : 1;
                    const preEditRootGen = currentRootGen - 1;
                    const delta = newRootGen - preEditRootGen;

                    const newParent = {
                        record_type: 'Person',
                        generation: newRootGen.toString(),
                        name: data.name.trim(),
                        sex: data.sex || '',
                        birth_date: data.birth_date || '',
                        birth_location: data.birth_location || '',
                        death_date: data.death_date || '',
                        death_location: data.death_location || '',
                        burial_location: data.burial_location || '',
                        service: data.service || '',
                        partners: [],
                        photos: [],
                        story: '',
                        attributes: '',
                        parents: data.parents || null,
                        notes: [],
                        unprocessed_items: [],
                        parent_ids: [],
                        children_no_other_parent: []
                    };

                    records.unshift(newParent);

                    // Apply delta to all non-root persons
                    records.slice(1).forEach(r => {
                        if (r.generation !== undefined) {
                            const oldGen = parseInt(r.generation);
                            r.generation = (oldGen + delta).toString();
                        }
                    });

                    if (debugMode) {
                        console.log(`AddParent: pre-edit = ${preEditRootGen}, new = ${newRootGen}, delta = ${delta}`);
                    }
                }
                
                safeCloseModal();
                debounceDisplayRecords();
                if (debugMode) console.log(`Saved ${mode} data:`, data);
            } catch (error) {
                if (debugMode) console.error(`Error in saveModalData(${mode}):`, error);
                safeShowError(`An unexpected error occurred: ${error.message}`);
            }
        }

        function toggleTable() {
            const tableContainer = document.getElementById('tableContainer');
            const isHidden = tableContainer.style.display === 'none';
            tableContainer.style.display = isHidden ? 'block' : 'none';
            if (isHidden && records.length > 0) debounceDisplayRecords();
            if (debugMode) console.log(`Table toggled: ${isHidden ? 'shown' : 'hidden'}`);
            }
        function debounceDisplayRecords() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(displayRecords, 16);
        }
        function toggleColumn(column) {
            if (vestigialColumns.has(column)) {
                vestigialColumns.delete(column);
                if (debugMode) console.log(`Restored column: ${column}`);
            } else {
                vestigialColumns.add(column);
                if (debugMode) console.log(`Collapsed column: ${column}`);
            }
            debounceDisplayRecords();
        }
        function isFieldEditable(recordType, field) {
            const cleanType = recordType ? recordType.toString().trim().toLowerCase() : '';
            const restrictions = fieldRestrictions[cleanType];
            if (!restrictions) { if (debugMode) console.log(`No restrictions for record_type='${cleanType}', field=${field}`); return false; }
            if (cleanType === 'person' && field === 'parents') { if (debugMode) console.log(`Field 'parents' is not editable in table for record_type='person'`); return false; }
            const isEditable = restrictions.editable.includes(field) && field !== 'attributes' && field !== 'sex';
            if (debugMode) console.log(`Checking editable: record_type='${cleanType}', field=${field}, isEditable=${isEditable}`);
            return isEditable;
        }
        function isFieldGreyedOut(recordType, field) {
            const cleanType = recordType ? recordType.toString().trim().toLowerCase() : '';
            const restrictions = fieldRestrictions[cleanType];
            if (!restrictions) { if (debugMode) console.log(`No restrictions for record_type='${cleanType}', field=${field}`); return false; }
            const isGreyedOut = restrictions.greyedOut.includes(field);
            if (debugMode) console.log(`Checking greyed-out: record_type='${cleanType}', field=${field}, isGreyedOut=${isGreyedOut}`);
            return isGreyedOut;
        }

        function displayRecords() {
            const mainPersons = records.filter(r => !r.isPartner);
            const minGen = mainPersons.length ? Math.min(...mainPersons.map(r => parseInt(r.generation || 9999))) : 1;
            const recordBody = document.getElementById('recordBody');
            recordBody.innerHTML = '';
            if (records.length === 0) return;

            // Build flat list: main person + their partners
            const flatRows = [];
            records.forEach((person, personIndex) => {
                // Only main persons (record_type 'Person') have partners array
                if (person.record_type === 'Person' || person.record_type === undefined) {
                    flatRows.push({ ...person, isPartner: false, personIndex });
                    if (Array.isArray(person.partners)) {
                        person.partners.forEach(partner => {
                            flatRows.push({
                                ...person,
                                ...partner,
                                name: partner.name || '',
                                record_type: 'Partner',
                                sex: '',
                                isPartner: true,
                                partnerData: partner,
                                personIndex,
                            });
                        });
                    }
                }
            });

            const table = document.createElement('table');
            const headerRow = document.createElement('tr');

            // === Define exact column order and display names (matches original CSV exactly) ===
            const columnConfig = [
                { key: 'record_type', label: 'record', width: '60px' },
                { key: 'gen', label: 'gen', width: '40px' },
                { key: 'name', label: 'name' },
                { key: 'sex', label: 'sex', width: '40px' },
                { key: 'birth_date', label: 'birth_date' },
                { key: 'birth_location', label: 'birth_location' },
                { key: 'death_date', label: 'death_date' },
                { key: 'death_location', label: 'death_location' },
                { key: 'burial_location', label: 'burial_location' },
                { key: 'burial_notes', label: 'burial_notes' },
                { key: 'service', label: 'service' },
                { key: 'marriage_date', label: 'marriage_date' },
                { key: 'relationship', label: 'relationship' },
                { key: 'divorced', label: 'divorced' },
                { key: 'divorce_date', label: 'divorce_date' },
                { key: 'parents', label: 'parents' },
                { key: 'attributes', label: 'attributes' },
                { key: 'unprocessed_items', label: 'unprocessed_items' },
                { key: 'notes', label: 'notes' },
                { key: 'story', label: 'story', vestigial: false }
            ];

            columnConfig.forEach(col => {

                const th = document.createElement('th');
                th.className = col.key;
                if (col.width) th.style.width = col.width;

                if (!['record_type', 'gen', 'name', 'sex'].includes(col.key)) {
                    const eye = document.createElement('span');
                    eye.textContent = vestigialColumns.has(col.key) ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è';
                    eye.className = 'action-icons';
                    eye.style.cursor = 'pointer';
                    eye.onclick = (e) => {
                        e.stopPropagation();
                        toggleColumn(col.key);
                    };
                    th.appendChild(eye);
                }

                const label = document.createElement('span');
                label.className = 'header-text';
                label.textContent = col.label;
                th.appendChild(label);

                if (vestigialColumns.has(col.key)) th.className += ' vestigial';
                headerRow.appendChild(th);
            });

            table.appendChild(headerRow);

            flatRows.forEach((row, flatIndex) => {
                const personIndex = row.personIndex;  // already available from flatRows
                const tr = document.createElement('tr');
                
                columnConfig.forEach(col => {
                    const td = document.createElement('td');
                    td.className = col.key;

                    if (col.key === 'story') {
                        const hasStory = row.isPartner
                            ? (row.partnerData.story || '').trim().length > 0
                            : (row.story || '').trim().length > 0;
                        const hasPhotos = row.isPartner
                            ? (row.partnerData.photos?.length > 0)
                            : (row.photos?.length > 0);

                        td.innerHTML = `
                            <span style="cursor:pointer; margin-right:10px; font-size:20px;" title="Edit story">
                                ${hasStory ? 'üìñ' : 'üìï'}
                            </span>
                            <span style="cursor:pointer; font-size:20px;" title="Photo gallery">
                                ${hasPhotos ? 'üì∏' : 'üì∑'}
                            </span>
                        `;

                        td.querySelector('span:first-child').onclick = (e) => {
                            e.stopPropagation();
                            if (row.isPartner) {
                                const partnerIdx = records[row.personIndex].partners.findIndex(p => p === row.partnerData);
                                openStoryModal(row.personIndex, partnerIdx);
                            } else {
                                openStoryModal(row.personIndex, null);
                            }
                        };

                        td.querySelector('span:last-child').onclick = (e) => {
                            e.stopPropagation();
                            if (row.isPartner) {
                                const partnerIdx = records[row.personIndex].partners.findIndex(p => p === row.partnerData);
                                openPhotoGallery(row.personIndex, partnerIdx);
                            } else {
                                openPhotoGallery(row.personIndex, null);
                            }
                        };

                    } else if (col.key === 'record_type') {
                        td.textContent = row.isPartner ? 'Partner' : 'Person';
                    } else if (col.key === 'gen') {
                        td.textContent = row.isPartner ? '' : (row.generation || '');
                        const isRoot = !row.isPartner && 
                            parseInt(row.generation || 9999) === minGen &&
                            row.personIndex === records.findIndex(r => 
                                parseInt(r.generation || 9999) === minGen && !r.isPartner
                            );
                        if (isRoot) {
                            td.className += ' editable';
                            td.style.cursor = 'pointer';
                            td.onclick = (e) => {
                                if (editingIndex === null) {
                                    e.stopPropagation();
                                    startEditing(row.personIndex, 'generation', td, td.textContent.trim(), null);
                                }
                            };
                        }
                    } else if (col.key === 'sex') {
                        td.textContent = row.isPartner ? '' : (row.sex || '');
                    } else {
                        const value = row[col.key];
                        td.textContent = (value === null || value === undefined) ? '' : String(value);
                    }

                    // Vestigial styling
                    if (vestigialColumns.has(col.key) && col.key !== 'story') {
                        td.className += ' vestigial';
                    }

                    // Editable cells (same rules as before)
                    const isMainPerson = !row.isPartner;
                    const field = col.key;

                    const editableMain = isMainPerson && ['name','sex','birth_date','birth_location','death_date','death_location','burial_location','service','attributes'].includes(field);
                    const editablePartner = row.isPartner && ['name','birth_date','birth_location','death_date','death_location','burial_location','service','marriage_date','relationship','divorced','divorce_date','parents'].includes(field);
                    
                    if ((editableMain || editablePartner) && !vestigialColumns.has(field)) {
                        td.className += ' editable';
                        td.style.cursor = 'pointer';
                        td.onclick = (e) => {
                            if (editingIndex === null) {
                                e.stopPropagation();

                                let partnerIdx = null;
                                if (row.isPartner) {
                                    partnerIdx = records[row.personIndex].partners.findIndex(p => p === row.partnerData);
                                }

                                startEditing(row.personIndex, field, td, td.textContent.trim(), partnerIdx);
                            }
                        };
                    }
                    tr.appendChild(td);
                });

                table.appendChild(tr);
            });

            recordBody.appendChild(table);
        }
        
        function startEditing(personIndex, field, td, currentValue, partnerIndex = null) {
            editingIndex = personIndex;
            editingField = field;

            td.innerHTML = '';

            // Special dropdowns
            if (field === 'sex' && partnerIndex === null) {
                const select = createSelect(['', 'male', 'female'], currentValue);
                td.appendChild(select);
                select.focus();
                select.onchange = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                select.onblur = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                return;
            }
            if (field === 'attributes' && partnerIndex === null) {
                const select = createSelect(['', 'stillborn', 'step', 'foster', 'adopted', 'continuation'], currentValue);
                td.appendChild(select);
                select.focus();
                select.onchange = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                select.onblur = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                return;
            }
            if (field === 'relationship' && partnerIndex !== null) {
                const select = createSelect(['', 'spouse', 'partner', 'other'], currentValue);
                td.appendChild(select);
                select.focus();
                select.onchange = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                select.onblur = () => saveEdit(personIndex, field, select.value, td, currentValue, partnerIndex);
                return;
            }

            // Default: textarea with full resize (vertical + horizontal) and multi-line support
            const textarea = document.createElement('textarea');
            textarea.className = 'edit-textarea';
            textarea.value = currentValue;

            // Initial rows: min 2, more for existing lines
            const lines = currentValue.split('\n').length;
            textarea.rows = Math.max(2, lines);

            // Full resize in both directions (vertical and horizontal)
            textarea.style.resize = 'both';  // This gives the grab handle for left/right + up/down

            // Auto-grow vertically as user types more lines
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            });

            // Initial sizing after insertion
            setTimeout(() => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            }, 0);

            td.appendChild(textarea);

            textarea.focus();
            textarea.select();
            
            let savedOnEnter = false;

            textarea.onkeydown = e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    savedOnEnter = true;
                    saveEdit(personIndex, field, textarea.value.trim(), td, currentValue, partnerIndex);
                    textarea.blur();
                } else if (e.key === 'Escape') {
                    cancelEdit(td, currentValue);
                }
            };

            textarea.onblur = () => {
                if (!savedOnEnter) {
                    saveEdit(personIndex, field, textarea.value.trim(), td, currentValue, partnerIndex);
                }
                savedOnEnter = false;
            };
        }
 
        // Helper for dropdowns
        function createSelect(options, selected) {
            const select = document.createElement('select');
            select.className = 'edit-select';
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt || '(none)';
                if (opt === selected) option.selected = true;
                select.appendChild(option);
            });
            return select;
        }

        function saveEdit(personIndex, field, value, td, oldValue, partnerIndex = null) {
            const trimmed = value.trim();

            // Validation
            if (dateFields.includes(field) && trimmed && !isValidDate(trimmed)) {
                safeShowError(`Invalid date in ${field}. Use YYYY, YYYY-MM, or YYYY-MM-DD.`);
                cancelEdit(td, oldValue);
                return;
            }
            if (field === 'relationship' && partnerIndex !== null && !['', 'spouse', 'partner', 'other'].includes(trimmed)) {
                safeShowError('Relationship must be spouse, partner, or other.');
                cancelEdit(td, oldValue);
                return;
            }

            const person = records[personIndex];

            if (partnerIndex === null) {
                // === ROOT GENERATION SPECIAL HANDLING (must come first) ===
                if (field === 'generation') {
                    const newGen = parseInt(trimmed);
                    if (isNaN(newGen) || newGen < 1) {
                        safeShowError('Generation must be ‚â•1');
                        cancelEdit(td, oldValue);
                        return;
                    }

                    const preEditRootGen = parseInt(oldValue || '1');

                    // Recalculate all descendants using their original offset from pre-edit root
                    records.slice(1).forEach(r => {
                        if (r.generation !== undefined) {
                            const relativeOffset = parseInt(r.generation) - preEditRootGen;
                            r.generation = (newGen + relativeOffset).toString();
                        }
                    });

                    person.generation = newGen.toString();

                    if (debugMode) {
                        console.log(`Root cell edit: pre=${preEditRootGen}, new=${newGen}`);
                        console.log('Final generations:', records.map((r, i) => `${i}: ${r.generation} (${r.name || 'Partner'})`));
                    }

                    // Restore content and redraw
                    td.innerHTML = '<span class="cell-content">' + (trimmed || '') + '</span>';
                    editingIndex = null;
                    editingField = null;
                    requestAnimationFrame(() => debounceDisplayRecords());
                    return;  // Skip normal update below
                }

                // Normal main person field update
                if (person[field] !== trimmed) {
                    person[field] = trimmed;
                    console.log(`Updated person[${personIndex}].${field} ‚Üí "${trimmed}"`);
                }
            } else {
                // Partner record
                const partner = person.partners[partnerIndex];
                if (partner && partner[field] !== trimmed) {
                    partner[field] = trimmed;
                    console.log(`Updated person[${personIndex}].partners[${partnerIndex}].${field} ‚Üí "${trimmed}"`);
                }
            }

            // Clean up and redraw (for non-generation edits)
            td.innerHTML = '<span class="cell-content">' + (trimmed || '') + '</span>';
            editingIndex = null;
            editingField = null;
            requestAnimationFrame(() => debounceDisplayRecords());
        }

        function saveNewParent() {
            const name = document.getElementById('parentName').value.trim();
            if (!name) {
                safeShowError('Name is required');
                return;
            }

            let currentRootGen = parseInt(records[0]?.generation, 10) || 1;

            const newParent = {
                record_type: 'Person',  // <--- ADD THIS 
                generation: currentRootGen,
                name: name,
                sex: document.getElementById('parentSex').value || '',
                birth_date: document.getElementById('parentBirthDate').value.trim(),
                birth_location: document.getElementById('parentBirthLocation').value.trim(),
                death_date: document.getElementById('parentDeathDate').value.trim(),
                death_location: document.getElementById('parentDeathLocation').value.trim(),
                burial_location: document.getElementById('parentBurialLocation').value.trim(),
                service: document.getElementById('parentService').value.trim(),
                partners: [],
                photos: [],
                story: '',
                attributes: '',
                parents: null
            };

            // Insert new parent at the very top of the records array
            records.unshift(newParent);

            safeCloseModal();
            debounceDisplayRecords();
        }

        function openPhotoGallery(personIndex, partnerIndex = null) {
    if (!records?.length) return safeShowError('No records loaded');

    safeOpenModal('photos');
    const isPartner = partnerRecordId !== null;
    const person = records[personIndex];
    const target = partnerIndex !== null ? person.partners[partnerIndex] : person;
    const name = isPartner ? `${target.name || '(unnamed)'} (Partner)` : person.name;

    if (!target.photos) target.photos = [];

    document.getElementById('modalTitle').textContent = `Photos ‚Äì ${name}`;

    document.getElementById('modalForm').innerHTML = `
        <div style="text-align:center; margin:20px 0;">
            <div id="photoDropZone" style="border:3px dashed #007bff; border-radius:12px; padding:40px; background:#f8f9ff; cursor:pointer;">
                <p style="margin:0; font-size:18px; color:#007bff;">Drop photos here or click to upload</p>
                <input type="file" id="photoUpload" multiple accept="image/*" style="display:none">
            </div>
        </div>
        <div id="photoGrid" style="display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:15px; max-height:70vh; overflow-y:auto; padding:10px;"></div>
        <div style="text-align:center; margin-top:20px;">
            <button type="button" onclick="closeModal()" style="padding:12px 30px; background:#666; color:white; border:none; border-radius:6px;">Close</button>
        </div>
    `;

    const dropZone = document.getElementById('photoDropZone');
    const uploadInput = document.getElementById('photoUpload');
    const grid = document.getElementById('photoGrid');

    dropZone.onclick = () => uploadInput.click();

    ['dragover', 'dragenter'].forEach(e => dropZone.addEventListener(e, ev => {
        ev.preventDefault();
        dropZone.style.background = '#e1f5fe';
    }));
    ['dragleave', 'dragend', 'drop'].forEach(e => dropZone.addEventListener(e, ev => {
        ev.preventDefault();
        if (e === 'drop' && ev.dataTransfer.files.length) handlePhotos(ev.dataTransfer.files, target, grid, personIndex, partnerRecordId);
        dropZone.style.background = '#f8f9ff';
    }));

    uploadInput.addEventListener('change', () => {
        if (uploadInput.files.length) handlePhotos(uploadInput.files, target, grid, personIndex, partnerRecordId);
    });

    renderPhotos(target, grid, personIndex, partnerIndex);

    new Sortable(grid, {
        animation: 150,
        onEnd: () => {
            const order = Array.from(grid.children).map(div => ({
                id: div.dataset.id,
                data: div.dataset.src,
                caption: div.querySelector('textarea').value
            }));
            target.photos = order;
        }
    });
}

        function handlePhotos(files, target, grid, personIndex, partnerRecordId) {
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = e => {
                    const id = 'photo_' + Date.now() + Math.floor(Math.random() * 10000);
                    target.photos.push({
                        id: id,
                        data: e.target.result,
                        caption: file.name.split('.').slice(0, -1).join('.') || 'Photo'
                    });
                    renderPhotos(target, grid, personIndex, partnerIndex);
                };
                reader.readAsDataURL(file);
            });
        }

        function renderPhotos(target, grid, personIndex, partnerRecordId) {
            // Safely handle missing or empty photos array
            if (!target || !target.photos || target.photos.length === 0) {
                grid.innerHTML = '<p style="grid-column:1/-1; text-align:center; color:#666; font-style:italic;">No photos yet</p>';
                return;
            }

            grid.innerHTML = '';

            target.photos.forEach((photo, i) => {
                // Safety: skip if photo or data is missing
                if (!photo || !photo.data) return;

                const div = document.createElement('div');
                div.dataset.id = photo.id;
                div.dataset.src = photo.data;
                div.style.cssText = 'border:1px solid #ddd; border-radius:8px; overflow:hidden; background:white; box-shadow:0 2px 8px rgba(0,0,0,0.1);';

                div.innerHTML = `
                    <div style="position:relative;">
                        <img src="${photo.data}" style="width:100%; height:auto; max-height:300px; object-fit:contain; background:#000; display:block;">
                        <button onclick="event.stopPropagation(); deletePhoto(${personIndex}, ${partnerIndex ? `'${partnerIndex}'` : 'null'}, '${photo.id}')" 
                                style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:white; border:none; border-radius:50%; width:32px; height:32px; cursor:pointer;">√ó</button>
                    </div>
                    <textarea placeholder="Caption..." style="width:100%; border:none; padding:8px; font-size:14px; resize:none; height:60px;">${photo.caption || ''}</textarea>
                `;

                div.querySelector('textarea').addEventListener('input', e => {
                    target.photos[i].caption = e.target.value;
                });

                grid.appendChild(div);
            });
        }

        function deletePhoto(personIndex, partnerIndex, photoId) {
            if (!confirm('Delete this photo permanently?')) return;
            const person = records[personIndex];
            const target = partnerIndex !== null ? person.partners[partnerIndex] : person;
            target.photos = target.photos.filter(p => p.id !== photoId);
            renderPhotos(target, document.getElementById('photoGrid'), personIndex, partnerIndex);
        }

        function initDebug() {
            if (window.location.search.includes('debug=1')) {
                (async () => {
                    const pp = await askPassphrase('DEBUG');
                    if (CryptoJS.SHA256(pp).toString() === debugPassphraseHash) {
                        debugMode = true;
                        console.log('DEBUG MODE ON');
                        document.getElementById('textFile').setAttribute('accept', '.zip,.json');
                    } else {
                        console.log('Debug mode disabled - incorrect passphrase');
                    }
                    decryptionPassphrase = null;
                })();
            }
        }
        initDebug();
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //  RESTORE: Connect the file input to handleFileSelect
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        document.getElementById('textFile').addEventListener('change', handleFileSelect);
    </script>
</body>
</html>
