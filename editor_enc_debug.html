<!DOCTYPE html>
<html lang="en">
<head>
    <title>Genealogy Record Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        /* Same as 2.1.35 */
    </style>
</head>
<body>
    <h2>Genealogy Record Editor</h2>
    <div class="info">
        <p><strong>Version:</strong> <span id="pageVersion">2.1.36</span></p>
        <p><strong>Last Updated:</strong> <span id="pageDate">2025-09-11 08:45:00 PDT</span></p>
    </div>
    <input type="file" id="textFile" accept=".csv,.csv.enc">
    <button onclick="processFile()">Load and Decrypt File</button>
    <button onclick="downloadRawFile()">Download Raw File</button>
    <div class="table-container">
        <div id="recordBody"></div>
    </div>
    <button onclick="downloadCSV()">Download Updated Records</button>

    <script>
        // ... (other functions unchanged)
        function bytesToHex(bytes) {
            const bytesArray = new Uint8Array(bytes.split('').map(c => c.charCodeAt(0)));
            return Array.from(bytesArray, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function decryptFile(encryptedData, passphrase) {
            try {
                computeFileHash(encryptedData).then(hash => {
                    console.log("Uploaded file SHA-256 hash:", hash);
                });
                const binaryData = arrayBufferToBinary(encryptedData);
                console.log("First 32 bytes (hex):", bytesToHex(binaryData.slice(0, 32)));
                if (binaryData.length < 32) throw new Error("Data too short for salt and IV");
                const saltBinary = binaryData.slice(0, 16);
                const ivBinary = binaryData.slice(16, 32);
                const ciphertextBinary = binaryData.slice(32);
                const saltHex = bytesToHex(saltBinary);
                const ivHex = bytesToHex(ivBinary);
                console.log("Salt (hex):", saltHex);
                console.log("IV (hex):", ivHex);
                console.log("Ciphertext length:", ciphertextBinary.length);
                console.log("Ciphertext (first 100 bytes, hex):", bytesToHex(ciphertextBinary.slice(0, 100)));
                const salt = CryptoJS.enc.Latin1.parse(saltBinary);
                const iv = CryptoJS.enc.Latin1.parse(ivBinary);
                const ciphertext = CryptoJS.enc.Latin1.parse(ciphertextBinary);
                const key = deriveKey(passphrase, salt);
                const decrypted = CryptoJS.AES.decrypt(
                    { ciphertext: ciphertext },
                    key,
                    { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }
                );
                console.log("Decrypted bytes length:", decrypted.sigBytes);
                console.log("Decrypted bytes (first 100 hex):", decrypted.toString(CryptoJS.enc.Hex).slice(0, 100));
                let result;
                try {
                    result = decrypted.toString(CryptoJS.enc.Utf8);
                    console.log("Decrypted CSV length:", result.length);
                    console.log("Decrypted CSV (first 100 chars):", result.slice(0, 100));
                    const blob = new Blob([result], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'decrypted_output.csv';
                    console.log("Initiating download of decrypted_output.csv");
                    a.click();
                    URL.revokeObjectURL(url);
                    return result;
                } catch (e) {
                    console.error("UTF-8 conversion failed:", e.message);
                    console.log("Raw decrypted bytes (full hex):", decrypted.toString(CryptoJS.enc.Hex));
                    try {
                        result = decrypted.toString(CryptoJS.enc.Latin1);
                        console.log("Decrypted CSV (Latin1) length:", result.length);
                        console.log("Decrypted CSV (first 100 chars):", result.slice(0, 100));
                        const blob = new Blob([result], { type: 'text/csv' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'decrypted_output_latin1.csv';
                        console.log("Initiating download of decrypted_output_latin1.csv");
                        a.click();
                        URL.revokeObjectURL(url);
                        return result;
                    } catch (e2) {
                        console.error("Latin1 conversion failed:", e2.message);
                        return { error: "Invalid UTF-8 and Latin1", decryptedHex: decrypted.toString(CryptoJS.enc.Hex) };
                    }
                }
            } catch (e) {
                console.error("Decryption error:", e.message);
                return { error: e.message, decryptedHex: null };
            }
        }
        // ... (rest of script unchanged)
    </script>
</body>
</html>
