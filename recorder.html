<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Genealogy Record Editor</title>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://unpkg.com;">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js" crossorigin="anonymous"></script>
    <script src="config.js"></script>
    <style>
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;font-size:18px;padding:20px;max-width:100%;margin:0 auto}
        .task-buttons{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;margin-bottom:20px}
        .task-btn{font-size:18px;padding:7.2px 14.4px;border-radius:7.2px;background:#007bff;color:white;border:none;cursor:pointer;min-width:135px;touch-action:manipulation}
        .task-btn:hover:not(.disabled-btn){background:#0056b3}
        .disabled-btn{background:#ccc;cursor:not-allowed;pointer-events:none}
        .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:1000}
        .modal-content{background:white;padding:20px;border-radius:10px;width:90%;max-width:400px;max-height:80vh;overflow-y:auto;box-shadow:0 4px 12px rgba(0,0,0,0.2)}
        .close{float:right;font-size:24px;cursor:pointer}
        .modal-content h3{margin-top:0;font-size:24px;text-align:center}
        .modal-content label{display:block;margin:10px 0 5px;font-size:18px}
        .modal-content input,.modal-content select,.modal-content textarea{width:100%;padding:10px;font-size:18px;border:1px solid #ccc;border-radius:5px;box-sizing:border-box}
        .modal-content .radio-group{display:flex;flex-direction:column;gap:10px;margin:20px 0}
        .modal-content .radio-label{display:flex;align-items:center;gap:10px;font-size:18px}
        .modal-content .radio-label input[type="radio"]{width:auto;cursor:pointer}
        .modal-content button{margin-top:20px;padding:12px 24px;font-size:18px;background:#28a745;color:white;border:none;border-radius:5px;cursor:pointer;width:100%;transition:background 0.2s}
        .modal-content button:hover{background:#218838}
        .table-container{margin-top:20px;overflow-x:auto}
        table{width:100%;font-size:14px;border-collapse:collapse}
        th,td{padding:8px;border:1px solid #ccc;white-space:normal;box-sizing:border-box}
        th.vestigial{padding:4px}
        th.record_type,td.record_type{width:60px}
        th.gen,td.gen{width:40px}
        th.sex,td.sex{width:40px}
        th.record_type.vestigial,td.record_type.vestigial,th.gen.vestigial,td.gen.vestigial,th.name.vestigial,td.name.vestigial,th.sex.vestigial,td.sex.vestigial{width:inherit!important}
        .action-icons{font-size:24px;margin-right:4px}
        .vestigial{width:36px!important;max-width:36px!important;min-width:0!important;overflow:hidden}
        .vestigial .header-text,.vestigial .cell-content{display:none}
        .editable-row:hover{background:#d9edf7}
        .highlighted-row{background:#ffffcc!important}
        .greyed-out{background:#c0c0c0;cursor:not-allowed}
        @media(max-width:768px){.task-btn{width:100%;margin-bottom:10px}.modal-content{width:95%;max-width:350px}}
        .title-container{display:flex;align-items:baseline;gap:96px;}
        .file-status{font-size:16px;color:#333;}
    </style>
</head>
<body>
    <div class="title-container">
        <h2>Genealogy Recorder <span style="font-size: 14px;">Version: <span id="pageVersion">1.0.12</span></span></h2>
        <span class="file-status" id="fileStatus">No records loaded</span>
    </div>
    <div class="info">
        <p class="warning">Data is deleted when you leave this page. Hit "Return Updates" when complete, to save your changes!</p>
    </div>
    <div class="task-buttons">
        <button onclick="loadFromDropbox()" class="task-btn" id="selectLoadBtn">Load Records üìÇ</button>
        <button onclick="openModal('addChild')" class="task-btn disabled-btn" id="addChildBtn">Add Child üë∂</button>
        <button onclick="openModal('addSpouse')" class="task-btn disabled-btn" id="addSpouseBtn">Add Partner üíç</button>
        <button onclick="openModal('updateRecord')" class="task-btn disabled-btn" id="updateRecordBtn">Update Record ‚úèÔ∏è</button>
        <button onclick="openModal('recordDeathBurial')" class="task-btn disabled-btn" id="recordDeathBurialBtn">Record Death/Burial ‚ö∞Ô∏è</button>
        <button onclick="toggleTable()" class="task-btn disabled-btn" id="viewTableBtn">View Table üìã</button>
        <button onclick="downloadCSV()" class="task-btn" id="returnUpdatesBtn" style="display:none;">Return Updates üì§</button>
        <button onclick="exitApp()" class="task-btn" id="exitBtn" style="display:none;">Exit üö™</button>
    </div>
    <input type="file" id="textFile" accept=".zip,.csv" style="display:none;" onchange="handleFileSelect()">
    <div id="tableContainer" class="table-container" style="display:none;">
        <div id="recordBody"></div>
    </div>
    <div id="modal" class="modal" style="display:none;">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="modalTitle"></h3>
            <form id="modalForm" autocomplete="off"></form>
        </div>
    </div>
    <script>
        let records = [], decryptionPassphrase = null, exchangePassphrase = null, originalFileName = 'records.zip';
        let debugMode = false, isInputCsv = false, isEncryptedZip = false;
        let modalMode = null, editingIndex = null, editingField = null, highlightedRow = null;
        let vestigialColumns = new Set(['notes', 'unprocessed_items']);
        let renderTimeout = null;
        let ticketNumber = null;
        let hasReturnedUpdates = false;
        const debugPassphraseHash = '0be92202d0978436fce6d8c863f4a2a3d63711a4e4444cb0734beea27315f2a5';
        const dateFields = ['birth_date', 'death_date', 'marriage_date'];
        const fieldRestrictions = {
            person: {
                editable: ['name', 'sex', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service', 'attributes', 'parents'],
                uneditable: ['record_type'],
                greyedOut: ['gen', 'marriage_date', 'relationship', 'divorced', 'divorce date']
            },
            spouse: {
                editable: ['name', 'birth_date', 'birth_location', 'death_date', 'death_location', 'burial_location', 'service', 'marriage_date', 'relationship', 'divorce', 'parents'],
                uneditable: ['record_type'],
                greyedOut: ['gen', 'sex']
            }
        };
        const DROPBOX_FOLDER = ''; // Root of /Apps/GenealogyRecorder
        async function getAccessToken() {
            try {
                const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: DROPBOX_REFRESH_TOKEN,
                        client_id: DROPBOX_APP_KEY,
                        client_secret: DROPBOX_APP_SECRET
                    })
                });
                const data = await response.json();
                if (data.error) throw new Error(data.error_description || 'Failed to refresh access token');
                if (debugMode) console.log('Access token retrieved');
                return data.access_token;
            } catch (err) {
                if (debugMode) console.error(`Token refresh error: ${err.message}`);
                throw new Error('Unable to authenticate with Dropbox');
            }
        }
        function safeOpenModal(mode) {
            if (window.location.search && !window.location.search.includes('debug=1'))
                window.history.replaceState({}, document.title, window.location.pathname);
            modalMode = mode;
            const modal = document.getElementById('modal');
            modal.style.display = 'block';
            const modalForm = document.getElementById('modalForm');
            modalForm.innerHTML = '';
            modalForm.addEventListener('submit', e => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            });
            if (debugMode) console.log(`Opened modal for ${mode}`);
        }
        function safeCloseModal() {
            document.getElementById('modal').style.display = 'none';
            modalMode = null;
            document.getElementById('modalForm').innerHTML = '';
            if (debugMode) console.log('Closed modal');
        }
        function safeShowError(message) {
            if (debugMode) console.error(`Error: ${message}`);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:20px;right:20px;background:#dc3545;color:white;padding:15px;border-radius:5px;z-index:2000;max-width:300px;box-shadow:0 2px 10px rgba(0,0,0,0.2);font-size:14px';
            errorDiv.innerHTML = `<strong>Error</strong><br>${message}<button onclick="this.parentElement.remove()" style="margin-left:10px;background:none;border:none;color:white;cursor:pointer;float:right">&times;</button>`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
        function showPopup(html) {
            const div = document.createElement('div');
            div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:20px;border:1px solid #000;z-index:10000';
            div.innerHTML = html + '<br><button onclick="this.parentElement.remove()">Close</button>';
            document.body.appendChild(div);
        }
        async function loadFromDropbox() {
            const passphrase = await askPassphrase('File Retrieval');
            if (!passphrase) {
                resetSession();
                return;
            }
            exchangePassphrase = passphrase;
            decryptionPassphrase = passphrase;
            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const fileHash = CryptoJS.SHA256(passphrase).toString();
                if (debugMode) console.log(`Hashed passphrase: ${fileHash}`);
              
                // List files in the Dropbox app folder
                const response = await dbx.filesListFolder({ path: DROPBOX_FOLDER });
                const fileEntry = response.result.entries
                    .filter(entry => entry.name.startsWith(fileHash) && entry.name.endsWith('.zip'))
                    .sort((a, b) => b.name.localeCompare(a.name))[0]; // Get latest file
              
                if (!fileEntry) {
                    safeShowError('No file found in Dropbox for the provided passphrase.');
                    resetSession();
                    return;
                }
                if (debugMode) console.log(`Found file: ${fileEntry.path_display}`);
              
                // Download the file
                const fileResponse = await dbx.filesDownload({ path: fileEntry.path_display });
                const buffer = await fileResponse.result.fileBlob.arrayBuffer();
                if (debugMode) {
                    console.log(`Downloaded file, size: ${buffer.byteLength} bytes`);
                    const uint8 = new Uint8Array(buffer.slice(0, 20));
                    console.log('Buffer sample (first 20 bytes):', Array.from(uint8).map(b => b.toString(16).padStart(2, '0')).join(' '));
                }
                // Decrypt the file
                let plainZip;
                try {
                    plainZip = decryptBlob(buffer, passphrase);
                } catch (err) {
                    safeShowError('Incorrect passphrase for decrypting the file.');
                    resetSession();
                    return;
                }
                if (debugMode) {
                    console.log(`Decrypted plainZip length: ${plainZip.length} bytes`);
                    console.log('PlainZip sample (first 20 chars):', plainZip.substring(0, 20));
                }
                // Parse ZIP to get CSV filename
                const zip = await JSZip.loadAsync(plainZip, { createFolders: true });
                const csvEntry = Object.values(zip.files).find(f => f.name.endsWith('.csv'));
                if (!csvEntry) {
                    safeShowError('No CSV found in ZIP');
                    resetSession();
                    return;
                }
                originalFileName = csvEntry.name.replace(/\.csv$/, '.zip');
                ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Unknown';
                document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Loaded`;
                if (debugMode) console.log(`Original filename: ${originalFileName}, Ticket: ${ticketNumber}`);
                // Process the ZIP
                isEncryptedZip = true;
                await loadZipFromBinary(plainZip);
                finishLoad();
            } catch (err) {
                if (debugMode) console.error(`Dropbox error: ${err.message}`);
                safeShowError(`Failed to load from Dropbox: ${err.message}`);
                resetSession();
            }
        }
        function askPassphrase(promptText) {
            return new Promise(resolve => {
                safeOpenModal('passphrase');
                document.getElementById('modalTitle').textContent = `Enter Passphrase for ${promptText}`;
                document.getElementById('modalForm').innerHTML = `
                    <form autocomplete="off">
                        <input type="hidden" name="dummy" value="no-save">
                        <label>Passphrase</label>
                        <input type="password" id="pp" autocomplete="off" data-lpignore="true" autofocus onkeydown="if(event.key === 'Enter'){event.preventDefault();resolvePass();}">
                        <button type="button" onclick="resolvePass()">Submit</button>
                    </form>
                `;
                window.resolvePass = () => {
                    const pp = document.getElementById('pp').value;
                    if (pp) {
                        safeCloseModal();
                        resolve(pp);
                    } else {
                        safeShowError('Passphrase required');
                        resolve(null);
                    }
                };
            });
        }
        function resetSession() {
            records = [];
            decryptionPassphrase = null;
            exchangePassphrase = null;
            originalFileName = 'records.zip';
            ticketNumber = null;
            isEncryptedZip = false;
            isInputCsv = false;
            hasReturnedUpdates = false;
            document.getElementById('requestEditBtn').style.display = 'block';
            document.getElementById('fileStatus').textContent = 'No records loaded';
            document.getElementById('textFile').value = '';
            document.getElementById('selectLoadBtn').style.display = 'block';
            document.getElementById('returnUpdatesBtn').style.display = 'none';
            document.getElementById('exitBtn').style.display = 'none';
            ['addChildBtn', 'addSpouseBtn', 'updateRecordBtn', 'recordDeathBurialBtn', 'viewTableBtn'].forEach(id =>
                document.getElementById(id).classList.add('disabled-btn'));
            document.getElementById('tableContainer').style.display = 'none';
            document.getElementById('recordBody').innerHTML = '';
            if (debugMode) console.log('Session reset');
        }
        function exitApp() {
            resetSession();
            window.close();
        }
        function handleFileSelect() {
            const file = document.getElementById('textFile').files[0];
            if (!file) return;
            originalFileName = file.name;
            ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Unknown';
            document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Loaded`;
            if (debugMode) console.log(`File selected: ${file.name}, Ticket: ${ticketNumber}`);
            const reader = new FileReader();
            reader.onload = e => processUploadedFile(e.target.result, file.name);
            reader.readAsArrayBuffer(file);
        }
        async function processUploadedFile(buffer, name) {
            isEncryptedZip = false;
            isInputCsv = false;
            try {
                if (debugMode) console.log(`Processing file: ${name}, size: ${buffer.byteLength} bytes`);
                if (name.toLowerCase().endsWith('.zip')) {
                    decryptionPassphrase = await askPassphrase(name);
                    if (debugMode) console.log(`Got passphrase for ${name}`);
                    const plainZip = decryptBlob(buffer, decryptionPassphrase);
                    if (debugMode) console.log(`Decrypted ZIP, length: ${plainZip.length} bytes`);
                    await loadZipFromBinary(plainZip);
                    isEncryptedZip = true;
                    finishLoad();
                    return;
                }
                if (debugMode && name.toLowerCase().endsWith('.csv')) {
                    if (debugMode) console.log(`Processing CSV: ${name}`);
                    const text = new TextDecoder().decode(buffer);
                    records = parseCSV(text);
                    isInputCsv = true;
                    finishLoad();
                    return;
                }
                throw new Error(`Unsupported file. Use .zip${debugMode ? ' or .csv' : ''}`);
            } catch (err) {
                if (debugMode) console.error(`Error processing file: ${err.message}`);
                safeShowError(err.message);
                resetSession();
            }
        }
        async function loadZipFromBinary(binaryString) {
            if (debugMode) console.log(`Loading ZIP, length: ${binaryString.length} bytes`);
            try {
                const zip = await JSZip.loadAsync(binaryString, { createFolders: true });
                const csvEntry = Object.values(zip.files).find(f => f.name.endsWith('.csv'));
                if (!csvEntry) throw new Error("No CSV found in ZIP");
                if (debugMode) console.log(`Found CSV in ZIP: ${csvEntry.name}`);
                const text = await csvEntry.async('text');
                records = parseCSV(text);
            } catch (err) {
                if (debugMode) console.error(`JSZip parsing error: ${err.message}`);
                throw err;
            }
        }
        function finishLoad() {
            enableButtonsAfterLoad();
            debounceDisplayRecords();
            if (debugMode) console.log(`Loaded records, Ticket: ${ticketNumber}`);
        }
        function deriveKey(passphrase, salt) {
            if (debugMode) console.log(`Deriving key with passphrase length: ${passphrase.length}, salt: ${salt.toString(CryptoJS.enc.Hex)}`);
            return CryptoJS.PBKDF2(passphrase, salt, { keySize: 8, iterations: 100000, hasher: CryptoJS.algo.SHA256 });
        }
        function decryptBlob(arrayBuffer, passphrase) {
            try {
                const data = new Uint8Array(arrayBuffer);
                if (debugMode) console.log(`DecryptBlob input: ${data.length} bytes`);
                if (data.length < 32) throw new Error("File too short for salt and IV");
                const salt = CryptoJS.lib.WordArray.create(data.slice(0, 16));
                const iv = CryptoJS.lib.WordArray.create(data.slice(16, 32));
                const ct = CryptoJS.lib.WordArray.create(data.slice(32));
                if (debugMode) console.log(`Salt: ${salt.toString(CryptoJS.enc.Hex)}, IV: ${iv.toString(CryptoJS.enc.Hex)}, Ciphertext: ${ct.sigBytes} bytes`);
                const key = deriveKey(passphrase, salt);
                const decrypted = CryptoJS.AES.decrypt({ ciphertext: ct }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
                if (debugMode) console.log(`Decryption completed, WordArray length: ${decrypted.sigBytes} bytes`);
                const decryptedBytes = CryptoJS.enc.Latin1.stringify(decrypted);
                if (!decryptedBytes) {
                    if (debugMode) console.log("Decrypted bytes empty");
                    throw new Error("Decryption failed, likely incorrect passphrase");
                }
                if (debugMode) console.log(`Decrypted bytes length: ${decryptedBytes.length}`);
                const padLen = decryptedBytes.charCodeAt(decryptedBytes.length - 1);
                if (debugMode) console.log(`Padding length: ${padLen}`);
                if (padLen < 1 || padLen > 16 || !decryptedBytes.slice(-padLen).split('').every(c => c.charCodeAt(0) === padLen)) {
                    if (debugMode) console.error(`Invalid padding, padLen: ${padLen}, last bytes: ${decryptedBytes.slice(-padLen)}`);
                    throw new Error("Invalid padding");
                }
                const result = decryptedBytes.slice(0, -padLen);
                if (debugMode) console.log(`Final decrypted length: ${result.length} bytes`);
                return result;
            } catch (err) {
                if (debugMode) console.error(`DecryptBlob error: ${err.message}`);
                throw new Error("Decryption failed: " + (err.message.includes("padding") || err.message.includes("passphrase") ? "Invalid passphrase or corrupted file" : err.message));
            }
        }
        function encryptBlob(zipBinaryString, passphrase) {
            const salt = CryptoJS.lib.WordArray.random(16);
            const iv = CryptoJS.lib.WordArray.random(16);
            const key = deriveKey(passphrase, salt);
            const len = zipBinaryString.length;
            const padLen = 16 - (len % 16);
            let padded = zipBinaryString;
            for (let i = 0; i < padLen; i++) padded += String.fromCharCode(padLen);
            if (debugMode) console.log(`Encrypting: plaintext=${len}B, padded=${padded.length}B`);
            const wordArray = CryptoJS.enc.Latin1.parse(padded);
            const encrypted = CryptoJS.AES.encrypt(wordArray, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
            const result = salt.concat(iv).concat(encrypted.ciphertext);
            if (debugMode) console.log(`Encryption complete: ciphertext=${result.sigBytes}B`);
            return result;
        }
        function escapeCSVField(f) {
            if (typeof f !== 'string') f = String(f);
            if (f.includes('"') || f.includes(',')) return `"${f.replace(/"/g, '""')}"`;
            return f;
        }
        function parseCSV(text) {
            if (debugMode) console.log(`Parsing CSV, length: ${text.length} bytes`);
            const lines = text.replace(/\r\n|\r/g, '\n').split('\n').filter(l => l.trim() && !l.trim().startsWith('#'));
            const headers = parseCSVLine(lines[0]);
            const recs = [];
            for (let i = 1; i < lines.length; i++) {
                const fields = parseCSVLine(lines[i]);
                if (fields.length === headers.length) {
                    const r = {};
                    headers.forEach((h, j) => r[h] = fields[j].trim());
                    recs.push(r);
                } else {
                    if (debugMode) console.log(`Skipped line ${i + 1}: field count mismatch (${fields.length} vs ${headers.length})`);
                }
            }
            if (debugMode) console.log(`Parsed ${recs.length} records`);
            return recs;
        }
        function parseCSVLine(line) {
            const fields = [];
            let field = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') { inQuotes = !inQuotes; continue; }
                if (char === ',' && !inQuotes) { fields.push(field); field = ''; continue; }
                field += char;
            }
            fields.push(field);
            return fields;
        }
        function buildCSV() {
            if (!records.length) return '';
            const headers = Object.keys(records[0]);
            const rows = [headers.map(escapeCSVField)];
            records.forEach(r => rows.push(headers.map(h => escapeCSVField(r[h] || ''))));
            return rows.join('\r\n') + '\r\n';
        }
        async function downloadCSV() {
            if (!records.length) return safeShowError('No data to save');
            if (!isInputCsv && !decryptionPassphrase) return safeShowError('No passphrase available');
            if (!exchangePassphrase && isEncryptedZip) return safeShowError('Exchange passphrase required for Dropbox upload');
            if (debugMode) console.log(`Building CSV for upload`);
            const csv = buildCSV();
            let blob;
            if (isInputCsv) {
                if (debugMode) console.log(`Generating CSV output: ${csv.length} bytes`);
                blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            } else {
                if (debugMode) console.log(`Generating ZIP with CSV: ${csv.length} bytes`);
                const zip = new JSZip();
                const csvFileName = `edited_${originalFileName.replace(/\.zip.*$/i, '')}.csv`;
                zip.file(csvFileName, csv);
                const zipBin = await zip.generateAsync({ type: 'uint8array' });
                if (debugMode) console.log(`ZIP generated: ${zipBin.length} bytes`);
                const encrypted = encryptBlob(String.fromCharCode.apply(null, zipBin), decryptionPassphrase);
                const uint8 = new Uint8Array(encrypted.sigBytes);
                for (let i = 0; i < encrypted.sigBytes; i++) {
                    const w = encrypted.words[Math.floor(i / 4)];
                    uint8[i] = (w >>> (24 - (i % 4) * 8)) & 0xFF;
                }
                blob = new Blob([uint8], { type: 'application/octet-stream' });
            }
          
            if (isEncryptedZip) {
                try {
                    const accessToken = await getAccessToken();
                    const dbx = new Dropbox.Dropbox({ accessToken });
                    const fileHash = CryptoJS.SHA256(exchangePassphrase).toString();
                    const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
                    const dropboxPath = `${DROPBOX_FOLDER}/${fileHash}_edited_${timestamp}.zip`;
                    if (debugMode) console.log(`Uploading updated file to ${dropboxPath}`);
                    await dbx.filesUpload({ contents: blob, path: dropboxPath, mode: 'overwrite' });
                    if (debugMode) console.log(`Successfully uploaded to ${dropboxPath}`);
                    showPopup(`Updated file saved to Dropbox as edited_${originalFileName}`);
                    hasReturnedUpdates = true;
                    document.getElementById('exitBtn').style.display = 'block';
                    document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Returned`;
                } catch (err) {
                    if (debugMode) console.error(`Dropbox upload error: ${err.message}`);
                    safeShowError(`Failed to upload to Dropbox: ${err.message}`);
                    return;
                }
            } else {
                safeShowError('Dropbox upload only supported for encrypted ZIP files.');
                return;
            }
        }
        function enableButtonsAfterLoad() {
            ['addChildBtn', 'addSpouseBtn', 'updateRecordBtn', 'recordDeathBurialBtn', 'viewTableBtn'].forEach(id =>
                document.getElementById(id).classList.remove('disabled-btn'));
            document.getElementById('selectLoadBtn').style.display = 'none';
            document.getElementById('requestEditBtn').style.display = 'none';
            document.getElementById('returnUpdatesBtn').style.display = 'block';
            if (hasReturnedUpdates) document.getElementById('exitBtn').style.display = 'block';
            if (debugMode) console.log('Enabled task buttons');
        }
        function dateToTimestamp(dateStr) {
            if (!dateStr) return Infinity;
            const parts = dateStr.split('-').map(Number);
            if (parts.length === 1) return parts[0] * 10000 * 100;
            if (parts.length === 2) return parts[0] * 10000 * 100 + parts[1] * 100;
            return parts[0] * 10000 * 100 + parts[1] * 100 + parts[2];
        }
        window.addEventListener('beforeunload', e => {
            if (modalMode) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        window.addEventListener('error', e => {
            if (e.message.includes('runtime.lastError')) {
                e.preventDefault();
                return false;
            }
        });
        function isValidDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return true;
            const parts = dateStr.split('-');
            if (parts.length === 1) {
                const year = parseInt(parts[0], 10);
                return !isNaN(year) && year >= 1 && year <= 9999;
            } else if (parts.length === 2) {
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                return !isNaN(year) && year >= 1 && year <= 9999 && !isNaN(month) && month >= 1 && month <= 12;
            } else if (parts.length === 3) {
                const date = Date.parse(dateStr + 'T00:00:00');
                if (isNaN(date)) return false;
                const parsedDate = new Date(date);
                return parsedDate.getFullYear() == parts[0] && (parsedDate.getMonth() + 1) == parts[1] && parsedDate.getDate() == parts[2];
            }
            return false;
        }
        function openModal(mode) {
            safeOpenModal(mode);
            const modalTitle = document.getElementById('modalTitle');
            const modalForm = document.getElementById('modalForm');
            let fields = [];
            if (mode === 'addChild') {
                modalTitle.textContent = 'Add Child';
                const selectablePeople = records.filter((r, index) => {
                    if (index === 0 && r.record_type.toLowerCase() === 'person') return false;
                    if (r.record_type.toLowerCase() === 'spouse') {
                        let nextPersonIndex = records.findIndex((rec, i) => i > index && rec.record_type.toLowerCase() === 'person');
                        if (nextPersonIndex === -1) nextPersonIndex = records.length;
                        return index > 0 && index < nextPersonIndex && records[0].record_type.toLowerCase() === 'person';
                    }
                    return true;
                }).filter(r => r.record_type.toLowerCase() === 'person');
                fields = [
                    { name: 'parents', label: 'Genealogical Parent Name', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'sex', label: 'Sex', type: 'select', options: ['', 'male', 'female'] },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' }
                ];
            } else if (mode === 'addSpouse') {
                modalTitle.textContent = 'Add Partner';
                const selectablePeople = records.filter((r, index) => {
                    if (index === 0 && r.record_type.toLowerCase() === 'person') return false;
                    if (r.record_type.toLowerCase() === 'spouse') {
                        let nextPersonIndex = records.findIndex((rec, i) => i > index && rec.record_type.toLowerCase() === 'person');
                        if (nextPersonIndex === -1) nextPersonIndex = records.length;
                        return index > 0 && index < nextPersonIndex && records[0].record_type.toLowerCase() === 'person';
                    }
                    return true;
                }).filter(r => r.record_type.toLowerCase() === 'person');
                fields = [
                    { name: 'partner', label: 'Select Genealogical Partner', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'relationship', label: 'Relationship', type: 'select', options: ['', 'spouse', 'partner', 'other'], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' },
                    { name: 'marriage_date', label: 'Marriage Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'parents', label: 'Parents', type: 'text', autocomplete: 'off' }
                ];
            } else if (mode === 'updateRecord') {
                modalTitle.textContent = 'Update Record';
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...records.map(r => `${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}`)], required: true },
                    { name: 'field', label: 'Field to Update', type: 'select', options: [''] },
                    { name: 'value', label: 'New Value', type: 'text', required: true }
                ];
            } else if (mode === 'recordDeathBurial') {
                modalTitle.textContent = 'Record Death/Burial';
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...records.map(r => `${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}`)], required: true },
                    { name: 'death_date', label: 'Death Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'death_location', label: 'Death Location', type: 'text' },
                    { name: 'burial_location', label: 'Burial Location', type: 'text' }
                ];
            }
            fields.forEach(field => {
                const label = document.createElement('label');
                label.textContent = field.label;
                if (field.required) label.innerHTML += ' <span style="color:red">*</span>';
                modalForm.appendChild(label);
                if (field.type === 'select') {
                    const select = document.createElement('select');
                    select.name = field.name;
                    if (field.required) select.required = true;
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt || '(Select)';
                        select.appendChild(option);
                    });
                    modalForm.appendChild(select);
                } else {
                    const input = document.createElement(field.type === 'textarea' ? 'textarea' : 'input');
                    input.type = field.type;
                    input.name = field.name;
                    if (field.required) input.required = true;
                    if (field.autocomplete) input.setAttribute('autocomplete', field.autocomplete);
                    modalForm.appendChild(input);
                }
            });
            const submitBtn = document.createElement('button');
            submitBtn.type = 'button';
            submitBtn.textContent = 'Save';
            submitBtn.onclick = () => {
                if (submitBtn.disabled) return;
                submitBtn.disabled = true;
                setTimeout(() => submitBtn.disabled = false, 1000);
                saveModalData(mode);
            };
            modalForm.appendChild(submitBtn);
            if (mode === 'updateRecord') {
                const recordSelect = modalForm.querySelector('select[name="record"]');
                const fieldSelect = modalForm.querySelector('select[name="field"]');
                recordSelect.addEventListener('change', () => {
                    const selectedRecord = recordSelect.value;
                    if (!selectedRecord) {
                        fieldSelect.innerHTML = '<option value=""></option>';
                        return;
                    }
                    const [recordType, name] = selectedRecord.split(': ');
                    const cleanType = recordType.toLowerCase() === 'partner' ? 'spouse' : 'person';
                    const editableFields = [...fieldRestrictions[cleanType].editable];
                    fieldSelect.innerHTML = '';
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    fieldSelect.appendChild(emptyOption);
                    editableFields.forEach(f => {
                        const option = document.createElement('option');
                        option.value = f;
                        option.textContent = f;
                        fieldSelect.appendChild(option);
                    });
                    fieldSelect.value = '';
                    fieldSelect.addEventListener('change', () => {
                        const valueInput = modalForm.querySelector('[name="value"]');
                        if (fieldSelect.value === 'attributes' && cleanType === 'person') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'stillborn', 'step', 'foster', 'adopted', 'continuation'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(None)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (fieldSelect.value === 'sex' && cleanType === 'person') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'male', 'female'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(Select)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (fieldSelect.value === 'relationship' && cleanType === 'spouse') {
                            const newSelect = document.createElement('select');
                            newSelect.name = 'value';
                            newSelect.required = true;
                            ['', 'spouse', 'partner', 'other'].forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt || '(Select)';
                                newSelect.appendChild(option);
                            });
                            valueInput.replaceWith(newSelect);
                        } else if (valueInput.tagName === 'SELECT') {
                            const newInput = document.createElement('input');
                            newInput.type = 'text';
                            newInput.name = 'value';
                            newInput.required = true;
                            valueInput.replaceWith(newInput);
                        }
                    });
                });
            }
        }
        function closeModal() { safeCloseModal(); }
        function saveModalData(mode) {
            try {
                const form = document.getElementById('modalForm');
                const data = {};
                for (let input of form.elements) {
                    if (input.name && input.type !== 'button') data[input.name] = input.value || '';
                }
                if (debugMode) console.log(`Processing ${mode} with data:`, data);
                if (mode === 'addChild') {
                    if (!data.name || !data.parents) { safeShowError('Name and Parent are required.'); return; }
                    const parent = records.find(r => r.name === data.parents && r.record_type.toLowerCase() === 'person');
                    if (!parent) { safeShowError('Invalid parent selected.'); return; }
                    if (data.birth_date && !isValidDate(data.birth_date)) { safeShowError('Invalid birth date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    const parentGen = parseInt(parent.gen) || 0;
                    const newRecord = {
                        record_type: 'Person',
                        gen: (parentGen + 1).toString(),
                        name: data.name,
                        sex: data.sex || '',
                        birth_date: data.birth_date || '',
                        birth_location: data.birth_location || '',
                        parents: '',
                        death_date: '',
                        death_location: '',
                        burial_location: '',
                        service: '',
                        marriage_date: '',
                        relationship: '',
                        divorce: '',
                        attributes: '',
                        unprocessed_items: '',
                        notes: ''
                    };
                    let insertIndex = records.indexOf(parent) + 1;
                    let treeEnd = records.length;
                    for (let i = insertIndex; i < records.length; i++) {
                        if (records[i].record_type.toLowerCase() === 'person' && (parseInt(records[i].gen) || 0) <= parentGen) {
                            treeEnd = i;
                            break;
                        }
                    }
                    if (debugMode) console.log(`Parent ${parent.name} (gen: ${parentGen}) descendant tree ends at index ${treeEnd}`);
                    const children = records.slice(insertIndex, treeEnd).filter(r => r.record_type.toLowerCase() == 'person' && (parseInt(r.gen) || 0) === parentGen + 1);
                    if (debugMode) console.log(`Found ${children.length} children for parent ${parent.name}`);
                    if (children.length > 0 && data.birth_date) {
                        const newTimestamp = dateToTimestamp(data.birth_date);
                        if (debugMode) console.log(`New child birth_date: ${data.birth_date}, timestamp: ${newTimestamp}`);
                        const sortedChildren = records.slice(insertIndex, treeEnd)
                            .reduce((acc, r, i) => r.record_type.toLowerCase() === 'person' && (parseInt(r.gen) || 0) === parentGen + 1 ? [...acc, { index: i + insertIndex, ts: dateToTimestamp(r.birth_date) }] : acc, [])
                            .sort((a, b) => a.ts - b.ts);
                        if (debugMode) console.log(`Sorted children:`, sortedChildren);
                        const insertPos = sortedChildren.findIndex(c => c.ts > newTimestamp);
                        insertIndex = insertPos === -1 ? treeEnd : sortedChildren[insertPos].index;
                        if (debugMode) console.log(`Inserting child at index ${insertIndex}`);
                    } else {
                        insertIndex = treeEnd;
                        if (debugMode) console.log(`No children or no birth_date, inserting at index ${insertIndex}`);
                    }
                    records.splice(insertIndex, 0, newRecord);
                    if (debugMode) console.log('Added child record:', newRecord, `at index ${insertIndex}`);
                } else if (mode === 'addSpouse') {
                    if (!data.name || !data.partner || !data.relationship) { safeShowError('Name, Select Genealogical Partner, and Relationship are required.'); return; }
                    const partner = records.find(r => r.name === data.partner && r.record_type.toLowerCase() === 'person');
                    if (!partner) { safeShowError('Invalid partner selected.'); return; }
                    if (data.birth_date && !isValidDate(data.birth_date)) { safeShowError('Invalid birth date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    if (data.marriage_date && !isValidDate(data.marriage_date)) { safeShowError('Invalid marriage date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    const newRecord = {
                        record_type: 'Spouse',
                        gen: '',
                        name: data.name,
                        sex: '',
                        birth_date: data.birth_date || '',
                        birth_location: data.birth_location || '',
                        parents: data.parents || '',
                        death_date: '',
                        death_location: '',
                        burial_location: '',
                        service: '',
                        marriage_date: data.marriage_date || '',
                        relationship: data.relationship,
                        divorce: '',
                        attributes: '',
                        unprocessed_items: '',
                        notes: ''
                    };
                    let insertIndex = records.indexOf(partner) + 1;
                    const spouses = records.slice(insertIndex).filter((r, i, arr) => r.record_type.toLowerCase() === 'spouse' && (i + insertIndex === records.length - 1 || records[i + insertIndex + 1].record_type.toLowerCase() !== 'spouse'));
                    if (debugMode) console.log(`Found ${spouses.length} spouses for partner ${partner.name}`);
                    if (spouses.length > 0 && data.marriage_date) {
                        const newTimestamp = dateToTimestamp(data.marriage_date);
                        if (debugMode) console.log(`New spouse marriage_date: ${data.marriage_date}, timestamp: ${newTimestamp}`);
                        const sortedSpouses = spouses.map((spouse, i) => ({ index: i + insertIndex, ts: dateToTimestamp(spouse.marriage_date) })).sort((a, b) => a.ts - b.ts);
                        if (debugMode) console.log(`Sorted spouses:`, sortedSpouses);
                        const insertPos = sortedSpouses.findIndex(s => s.ts > newTimestamp);
                        insertIndex = insertPos === -1 ? sortedSpouses[sortedSpouses.length - 1].index + 1 : sortedSpouses[insertPos].index;
                        if (debugMode) console.log(`Inserting spouse at index ${insertIndex}`);
                    }
                    records.splice(insertIndex, 0, newRecord);
                    if (debugMode) console.log('Added spouse record:', newRecord, `at index ${insertIndex}`);
                } else if (mode === 'updateRecord') {
                    if (!data.record || !data.field) { safeShowError('Please select a record and field.'); return; }
                    if (!data.value && data.field !== 'attributes' && data.field !== 'sex') { safeShowError('Please enter a value.'); return; }
                    const [recordType, name] = data.record.split(': ');
                    const record = records.find(r => (r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type) === recordType && r.name === name);
                    if (!record) { safeShowError('Invalid record selected.'); return; }
                    if (data.field === 'relationship' && !['', 'spouse', 'partner', 'other'].includes(data.value)) { safeShowError('Relationship must be "spouse", "partner", or "other".'); return; }
                    if (data.field === 'attributes' && !['', 'stillborn', 'step', 'foster', 'adopted', 'continuation'].includes(data.value)) { safeShowError('Attributes must be one of: None, stillborn, step, foster, adopted, continuation.'); return; }
                    if (data.field === 'sex' && !['', 'male', 'female'].includes(data.value)) { safeShowError('Sex must be one of: male, female, or empty.'); return; }
                    if (data.field === 'divorce' && data.value && data.value !== 'true' && !isValidDate(data.value)) { safeShowError('Divorce must be a valid date, "true", or empty.'); return; }
                    if (dateFields.includes(data.field) && data.value && !isValidDate(data.value)) { safeShowError('Invalid date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    const cleanType = recordType.toLowerCase() === 'partner' ? 'spouse' : 'person';
                    const isEditable = fieldRestrictions[cleanType].editable.includes(data.field);
                    if (isEditable) {
                        const oldValue = record[data.field];
                        record[data.field] = data.value;
                        if (debugMode) console.log(`Updated ${data.field} from "${oldValue}" to "${data.value}" for ${name}`);
                    } else {
                        safeShowError('Selected field is not editable.');
                        return;
                    }
                } else if (mode === 'recordDeathBurial') {
                    if (!data.record) { safeShowError('Please select a record.'); return; }
                    const [recordType, name] = data.record.split(': ');
                    const record = records.find(r => (r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type) === recordType && r.name === name);
                    if (!record) { safeShowError('Invalid record selected.'); return; }
                    if (data.death_date && !isValidDate(data.death_date)) { safeShowError('Invalid death date. Use YYYY, YYYY-MM, or YYYY-MM-DD.'); return; }
                    let updated = false;
                    if (data.death_date && isFieldEditable(record.record_type, 'death_date')) { record.death_date = data.death_date; updated = true; }
                    if (data.death_location && isFieldEditable(record.record_type, 'death_location')) { record.death_location = data.death_location; updated = true; }
                    if (data.burial_location && isFieldEditable(record.record_type, 'burial_location')) { record.burial_location = data.burial_location; updated = true; }
                    if (!updated) { safeShowError('At least one field (Death Date, Death Location, or Burial Location) must be provided and editable.'); return; }
                    if (debugMode) console.log(`Updated death/burial info for ${name}`);
                }
                safeCloseModal();
                debounceDisplayRecords();
                if (debugMode) console.log(`Saved ${mode} data:`, data);
            } catch (error) {
                if (debugMode) console.error(`Error in saveModalData(${mode}):`, error);
                safeShowError(`An unexpected error occurred: ${error.message}`);
            }
        }
        function toggleTable() {
            const tableContainer = document.getElementById('tableContainer');
            const isHidden = tableContainer.style.display === 'none';
            tableContainer.style.display = isHidden ? 'block' : 'none';
            if (isHidden && records.length > 0) debounceDisplayRecords();
            if (debugMode) console.log(`Table toggled: ${isHidden ? 'shown' : 'hidden'}`);
        }
        function debounceDisplayRecords() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(displayRecords, 16);
        }
        function toggleColumn(column) {
            if (vestigialColumns.has(column)) {
                vestigialColumns.delete(column);
                if (debugMode) console.log(`Restored column: ${column}`);
            } else {
                vestigialColumns.add(column);
                if (debugMode) console.log(`Collapsed column: ${column}`);
            }
            debounceDisplayRecords();
        }
        function isFieldEditable(recordType, field) {
            const cleanType = recordType ? recordType.toString().trim().toLowerCase() : '';
            const restrictions = fieldRestrictions[cleanType];
            if (!restrictions) { if (debugMode) console.log(`No restrictions for record_type='${cleanType}', field=${field}`); return false; }
            if (cleanType === 'person' && field === 'parents') { if (debugMode) console.log(`Field 'parents' is not editable in table for record_type='person'`); return false; }
            const isEditable = restrictions.editable.includes(field) && field !== 'attributes' && field !== 'sex';
            if (debugMode) console.log(`Checking editable: record_type='${cleanType}', field=${field}, isEditable=${isEditable}`);
            return isEditable;
        }
        function isFieldGreyedOut(recordType, field) {
            const cleanType = recordType ? recordType.toString().trim().toLowerCase() : '';
            const restrictions = fieldRestrictions[cleanType];
            if (!restrictions) { if (debugMode) console.log(`No restrictions for record_type='${cleanType}', field=${field}`); return false; }
            const isGreyedOut = restrictions.greyedOut.includes(field);
            if (debugMode) console.log(`Checking greyed-out: record_type='${cleanType}', field=${field}, isGreyedOut=${isGreyedOut}`);
            return isGreyedOut;
        }
        function displayRecords() {
            const recordBody = document.getElementById('recordBody');
            recordBody.innerHTML = '';
            if (records.length === 0) { if (debugMode) console.log('No records to display'); return; }
            if (debugMode) console.log(`Displaying ${records.length} records`);
            const table = document.createElement('table');
            const headerRow = document.createElement('tr');
            const headers = Object.keys(records[0]).filter(header => !['notes', 'unprocessed_items'].includes(header));
            headers.forEach(header => {
                const th = document.createElement('th');
                th.className = header;
                if (!['record_type', 'gen', 'name', 'sex'].includes(header)) {
                    const toggleButton = document.createElement('span');
                    toggleButton.textContent = vestigialColumns.has(header) ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è';
                    toggleButton.className = 'action-icons';
                    toggleButton.onclick = () => toggleColumn(header);
                    th.appendChild(toggleButton);
                }
                const headerText = document.createElement('span');
                headerText.textContent = header === 'record_type' ? 'record' : header === 'sex' ? 'sex' : header;
                headerText.className = 'header-text';
                th.appendChild(headerText);
                if (vestigialColumns.has(header) && !['record_type', 'gen', 'name', 'sex'].includes(header)) th.className += ' vestigial';
                headerRow.appendChild(th);
            });
            table.appendChild(headerRow);
            records.forEach((record, index) => {
                const tr = document.createElement('tr');
                if (index === highlightedRow) tr.className = 'highlighted-row';
                tr.className += ' editable-row';
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = header;
                    const cellContent = document.createElement('span');
                    const displayValue = header === 'record_type' && record[header].toLowerCase() === 'spouse' ? 'Partner' : header === 'sex' ? (record[header] || '') : record[header] || '';
                    cellContent.textContent = displayValue;
                    cellContent.className = 'cell-content';
                    td.appendChild(cellContent);
                    const isEditable = isFieldEditable(record.record_type, header);
                    const isGrey = isFieldGreyedOut(record.record_type, header);
                    if (isEditable && !vestigialColumns.has(header)) {
                        td.className += ' editable';
                        td.addEventListener('click', e => {
                            if (editingIndex === null) {
                                startEditing(index, header, td, cellContent.textContent);
                                e.stopPropagation();
                                if (debugMode) console.log(`Cell clicked: record ${index + 1}, field ${header}`);
                            }
                        });
                    } else if (isGrey) {
                        td.className += ' greyed-out';
                    }
                    if (vestigialColumns.has(header) && !['record_type', 'gen', 'name', 'sex'].includes(header)) td.className += ' vestigial';
                    tr.appendChild(td);
                });
                tr.addEventListener('click', e => {
                    if (editingIndex === null && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
                        highlightedRow = (highlightedRow === index) ? null : index;
                        if (debugMode) console.log(`Row ${highlightedRow !== null ? highlightedRow + 1 : 'none'} highlighted`);
                        debounceDisplayRecords();
                    }
                });
                table.appendChild(tr);
            });
            recordBody.appendChild(table);
            if (debugMode) console.log(`Displayed ${records.length} records`);
        }
        function startEditing(index, field, td, currentValue) {
            editingIndex = index;
            editingField = field;
            td.innerHTML = '';
            if (field === 'relationship' && records[index].record_type.toLowerCase() === 'spouse') {
                const select = document.createElement('select');
                select.className = 'edit-select';
                ['', 'spouse', 'partner', 'other'].forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt || '(Select)';
                    if (opt === currentValue) option.selected = true;
                    select.appendChild(option);
                });
                td.appendChild(select);
                select.focus();
                if (debugMode) console.log(`Started editing record ${index + 1}, field: ${field} with dropdown`);
                select.onchange = () => saveEdit(index, field, select.value, td, currentValue);
                select.onblur = () => saveEdit(index, field, select.value, td, currentValue);
                select.onkeydown = e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveEdit(index, field, select.value, td, currentValue);
                    } else if (e.key === 'Escape') {
                        cancelEdit(td, currentValue);
                    }
                };
            } else {
                const textarea = document.createElement('textarea');
                textarea.className = 'edit-textarea';
                textarea.value = currentValue;
                textarea.rows = Math.max(2, currentValue.split('\n').length);
                td.appendChild(textarea);
                textarea.focus();
                if (debugMode) console.log(`Started editing record ${index + 1}, field: ${field} with textarea`);
                textarea.onblur = () => saveEdit(index, field, textarea.value, td, currentValue);
                textarea.onkeydown = e => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        saveEdit(index, field, textarea.value, td, currentValue);
                    } else if (e.key === 'Escape') {
                        cancelEdit(td, currentValue);
                    }
                };
            }
        }
        function saveEdit(index, field, value, td, currentValue) {
            const trimmedValue = value.trim();
            if (dateFields.includes(field) && trimmedValue && trimmedValue !== 'true' && !isValidDate(trimmedValue)) {
                safeShowError(`Invalid date format for ${field}. Use YYYY, YYYY-MM, or YYYY-MM-DD.`);
                cancelEdit(td, currentValue);
                return;
            }
            if (field === 'relationship' && !['', 'spouse', 'partner', 'other'].includes(trimmedValue)) {
                safeShowError('Relationship must be "spouse", "partner", or "other".');
                cancelEdit(td, currentValue);
                return;
            }
            if (trimmedValue !== currentValue) {
                records[index][field] = trimmedValue;
                if (debugMode) console.log(`Saved edit: record ${index + 1}, field ${field}, value ${trimmedValue}`);
            }
            editingIndex = null;
            editingField = null;
            td.innerHTML = '';
            const cellContent = document.createElement('span');
            cellContent.textContent = trimmedValue;
            cellContent.className = 'cell-content';
            td.appendChild(cellContent);
            debounceDisplayRecords();
        }
        function cancelEdit(td, currentValue) {
            editingIndex = null;
            editingField = null;
            td.innerHTML = '';
            const cellContent = document.createElement('span');
            cellContent.textContent = currentValue;
            cellContent.className = 'cell-content';
            td.appendChild(cellContent);
            if (debugMode) console.log('Cancelled edit');
            debounceDisplayRecords();
        }
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // NEW: Request New Edit Package (self-service)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function openRequestModal() {
            safeOpenModal('requestEdit');
            document.getElementById('modalTitle').textContent = 'Request New Edit Package';
            document.getElementById('modalForm').innerHTML = `
                <label>Your Full Name <span style="color:red">*</span></label>
                <input type="text" required>

                <label>Your Email <span style="color:red">*</span></label>
                <input type="email" required>

                <label>Starting Person Full Name (exactly as in the tree) <span style="color:red">*</span></label>
                <input type="text" required>

                <label>Your Relationship to This Person (e.g. grandson, niece, self) <span style="color:red">*</span></label>
                <input type="text" required>

                <label>Desired Passphrase (optional ‚Äì leave blank and I will choose one)</label>
                <input type="text" placeholder="e.g. Banana42">

                <button type="button" onclick="submitEditRequest()">Submit Request</button>
            `;
        }

        async function submitEditRequest() {
            const inputs = document.querySelectorAll('#modalForm input');
            const data = {
                timestamp: new Date().toISOString(),
                requestor_name: inputs[0].value.trim(),
                requestor_email: inputs[1].value.trim(),
                starting_person: inputs[2].value.trim(),
                relationship: inputs[3].value.trim(),
                desired_passphrase: inputs[4].value.trim() || null
            };

            if (!data.requestor_name || !data.requestor_email || !data.starting_person || !data.relationship) {
                safeShowError('Please fill in all required fields.');
                return;
            }

            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });

                const now = new Date();
                const datePart = now.toISOString().slice(0,10).replace(/-/g,'');
                const timePart = now.toTimeString().slice(0,8).replace(/:/g,'');
                const safeName = data.requestor_name.replace(/[^a-zA-Z0-9]/g, '_').slice(0,20);
                const filename = `requests/${datePart}_${timePart}_${safeName}.json`;

                const content = JSON.stringify(data, null, 2);

                await dbx.filesUpload({
                    contents: content,
                    path: DROPBOX_FOLDER + '/' + filename,
                    mode: { '.tag': 'add' },
                    autorename: true
                });

                safeCloseModal();
                showPopup(`
                    <h3 style="color:green">‚úì Request Submitted Successfully!</h3>
                    <p>Your request has been saved as:<br><b>${filename}</b></p>
                    <p>I will prepare your personal edit package shortly.<br>
                    ${data.desired_passphrase ? 'I will use your chosen passphrase.' : 'I will email you the passphrase when ready.'}</p>
                `);

            } catch (err) {
                safeShowError('Failed to submit request: ' + err.message);
                console.error(err);
            }
        }
        function initDebug() {
            if (window.location.search.includes('debug=1')) {
                (async () => {
                    const pp = await askPassphrase('DEBUG');
                    if (CryptoJS.SHA256(pp).toString() === debugPassphraseHash) {
                        debugMode = true;
                        console.log('DEBUG MODE ON');
                        document.getElementById('textFile').setAttribute('accept', '.zip,.csv');
                    } else {
                        console.log('Debug mode disabled - incorrect passphrase');
                    }
                    decryptionPassphrase = null;
                })();
            }
        }
        initDebug();
    </script>
</body>
</html>
