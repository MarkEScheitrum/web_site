                <textarea id="issueDesc" rows="6" required></textarea>

                <button type="button" onclick="submitIssue()">Submit Issue</button>
            `;
        }

        async function submitIssue() {
            const title = document.getElementById('issueTitle').value.trim();
            const desc = document.getElementById('issueDesc').value.trim();
            if (!title || !desc) {
                safeShowError('Both title and description are required');
                return;
            }

            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;

            const data = {
                timestamp: `${year}-${month}-${day} ${hours}:${minutes}:${seconds} PST`,
                ticket_number: ticketNumber || "none",
                issue_title: title,
                issue_description: desc
            };

            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const filename = `issues/issue_${timestamp}_${ticketNumber || 'none'}.json`;

                await dbx.filesUpload({
                    contents: JSON.stringify(data, null, 2),
                    path: DROPBOX_FOLDER + '/' + filename,
                    mode: { '.tag': 'add' },
                    autorename: true
                });

                safeCloseModal();
                showPopup(`
                    <h3 style="color:green">âœ“ Issue Reported</h3>
                    <p>Thank you! Your issue has been saved as:</p>
                    <b>${filename}</b>
                    <p>We will review it shortly.</p>
                `);
            } catch (err) {
                safeShowError('Failed to submit issue: ' + err.message);
            }
        }

        // ==================== ALL ORIGINAL FUNCTIONS BELOW (unchanged) ====================
        async function loadFromDropbox() {
            const passphrase = await askPassphrase('File Retrieval');
            if (!passphrase) return;
            exchangePassphrase = passphrase;
            decryptionPassphrase = passphrase;
            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const fileHash = CryptoJS.SHA256(passphrase).toString();
                const response = await dbx.filesListFolder({ path: DROPBOX_FOLDER });
                const fileEntry = response.result.entries
                    .filter(e => e.name.startsWith(fileHash) && e.name.endsWith('.zip'))
                    .sort((a, b) => b.name.localeCompare(a.name))[0];
                if (!fileEntry) {
                    safeShowError('No file found in Dropbox for the provided passphrase.');
                    return;
                }
                const fileResponse = await dbx.filesDownload({ path: fileEntry.path_display });
                const buffer = await fileResponse.result.fileBlob.arrayBuffer();
                const plainZip = decryptBlob(buffer, passphrase);
                const zip = await JSZip.loadAsync(plainZip);
                const csvEntry = Object.values(zip.files).find(f => f.name.endsWith('.csv'));
                if (!csvEntry) throw new Error('No CSV found in ZIP');
                originalFileName = csvEntry.name.replace(/\.csv$/, '.zip');
                ticketNumber = originalFileName.match(/records_(\d+)\.zip/)?.[1] || 'Unknown';
                document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Loaded`;
                const text = await csvEntry.async('text');
                records = parseCSV(text);
                isEncryptedZip = true;
                finishLoad();
            } catch (err) {
                safeShowError(`Failed to load from Dropbox: ${err.message}`);
                resetSession();
            }
        }

        function askPassphrase(promptText) {
            return new Promise(resolve => {
                safeOpenModal('passphrase');
                document.getElementById('modalTitle').textContent = `Enter Passphrase for ${promptText}`;
                document.getElementById('modalForm').innerHTML = `
                    <label>Passphrase</label>
                    <input type="password" id="pp" autocomplete="off" data-lpignore="true" autofocus>
                    <button type="button" onclick="window.resolvePass()">Submit</button>
                `;
                window.resolvePass = () => {
                    const val = document.getElementById('pp').value;
                    safeCloseModal();
                    resolve(val || null);
                };
            });
        }

        function resetSession() {
            records = [];
            decryptionPassphrase = null;
            exchangePassphrase = null;
            originalFileName = 'records.zip';
            ticketNumber = null;
            isEncryptedZip = false;
            isInputCsv = false;
            hasReturnedUpdates = false;
            document.getElementById('selectLoadBtn').style.display = 'block';
            document.getElementById('requestEditBtn').style.display = 'block';
            ['addChildBtn','addSpouseBtn','updateRecordBtn','recordDeathBurialBtn','viewTableBtn','returnUpdatesBtn','exitBtn'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById('fileStatus').textContent = 'No records loaded';
            document.getElementById('tableContainer').style.display = 'none';
            document.getElementById('recordBody').innerHTML = '';
        }

        function enableButtonsAfterLoad() {
            document.getElementById('selectLoadBtn').style.display = 'none';
            document.getElementById('requestEditBtn').style.display = 'none';
            ['addChildBtn','addSpouseBtn','updateRecordBtn','recordDeathBurialBtn','viewTableBtn'].forEach(id => {
                document.getElementById(id).style.display = 'block';
                document.getElementById(id).classList.remove('disabled-btn');
            });
            document.getElementById('returnUpdatesBtn').style.display = 'block';
        }

        function finishLoad() {
            enableButtonsAfterLoad();
            debounceDisplayRecords();
        }

        function exitApp() {
            if (confirm("Are you sure you want to exit? Any unsaved changes will be lost.")) {
                resetSession();
            }
        }

        function openRequestModal() {
            safeOpenModal('requestEdit');
            document.getElementById('modalTitle').textContent = 'Request New Edit Package';
            document.getElementById('modalForm').innerHTML = `
                <label>Your Full Name <span style="color:red">*</span></label>
                <input type="text" required>
                <label>Your Email <span style="color:red">*</span></label>
                <input type="email" required>
                <label>Starting Person Full Name (exactly as in the tree) <span style="color:red">*</span></label>
                <input type="text" required>
                <label>Starting Person Birth Year (e.g. 1946) <span style="color:red">*</span></label>
                <input type="text" pattern="[0-9]{4}" placeholder="e.g. 1946" required>
                <label>Your Relationship to This Person (e.g. grandson, niece, self) <span style="color:red">*</span></label>
                <input type="text" required>
                <div class="note">
                    An acknowledgement email containing a passphrase will be sent to the email address above.
                </div>
                <button type="button" onclick="submitEditRequest()">Submit Request</button>
            `;
        }

        async function submitEditRequest() {
            const inputs = document.querySelectorAll('#modalForm input');
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const tz = now.toLocaleTimeString('en-us', { timeZoneName: 'short' }).split(' ')[2];
            const formattedTimestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${tz}`;
            const data = {
                timestamp: formattedTimestamp,
                requestor_name: inputs[0].value.trim(),
                requestor_email: inputs[1].value.trim(),
                starting_person: inputs[2].value.trim(),
                starting_person_birth_year: inputs[3].value.trim(),
                relationship: inputs[4].value.trim()
            };
            if (Object.values(data).some(v => v === '')) {
                safeShowError('Please fill in all required fields.');
                return;
            }
            try {
                const accessToken = await getAccessToken();
                const dbx = new Dropbox.Dropbox({ accessToken });
                const datePart = now.toISOString().slice(0,10).replace(/-/g,'');
                const timePart = now.toTimeString().slice(0,8).replace(/:/g,'');
                const safeName = data.requestor_name.replace(/[^a-zA-Z0-9]/g, '_').slice(0,20);
                const filename = `requests/request_${datePart}_${timePart}_${safeName}.json`;
                await dbx.filesUpload({
                    contents: JSON.stringify(data, null, 2),
                    path: DROPBOX_FOLDER + '/' + filename,
                    mode: { '.tag': 'add' },
                    autorename: true
                });
                safeCloseModal();
                showPopup(`
                    <h3 style="color:green">âœ“ Request Submitted Successfully!</h3>
                    <p><strong>Request Time:</strong> ${formattedTimestamp}</p>
                    <p>Your request has been saved as:<br><b>${filename}</b></p>
                    <p>I will prepare your edit package and send you a passphrase by email shortly.</p>
                `);
            } catch (err) {
                safeShowError('Failed to submit request: ' + err.message);
            }
        }

        function deriveKey(passphrase, salt) {
            return CryptoJS.PBKDF2(passphrase, salt, { keySize: 8, iterations: 100000, hasher: CryptoJS.algo.SHA256 });
        }

        function decryptBlob(arrayBuffer, passphrase) {
            const data = new Uint8Array(arrayBuffer);
            if (data.length < 32) throw new Error("File too short");
            const salt = CryptoJS.lib.WordArray.create(data.slice(0, 16));
            const iv = CryptoJS.lib.WordArray.create(data.slice(16, 32));
            const ct = CryptoJS.lib.WordArray.create(data.slice(32));
            const key = deriveKey(passphrase, salt);
            const decrypted = CryptoJS.AES.decrypt({ ciphertext: ct }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
            const decryptedBytes = CryptoJS.enc.Latin1.stringify(decrypted);
            const padLen = decryptedBytes.charCodeAt(decryptedBytes.length - 1);
            if (padLen < 1 || padLen > 16) throw new Error("Invalid padding");
            return decryptedBytes.slice(0, -padLen);
        }

        function encryptBlob(zipBinaryString, passphrase) {
            const salt = CryptoJS.lib.WordArray.random(16);
            const iv = CryptoJS.lib.WordArray.random(16);
            const key = deriveKey(passphrase, salt);
            const len = zipBinaryString.length;
            const padLen = 16 - (len % 16);
            let padded = zipBinaryString;
            for (let i = 0; i < padLen; i++) padded += String.fromCharCode(padLen);
            const wordArray = CryptoJS.enc.Latin1.parse(padded);
            const encrypted = CryptoJS.AES.encrypt(wordArray, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding });
            return salt.concat(iv).concat(encrypted.ciphertext);
        }

        function escapeCSVField(f) {
            if (typeof f !== 'string') f = String(f);
            if (f.includes('"') || f.includes(',')) return `"${f.replace(/"/g, '""')}"`;
            return f;
        }

        function parseCSV(text) {
            const lines = text.replace(/\r\n|\r/g, '\n').split('\n').filter(l => l.trim() && !l.trim().startsWith('#'));
            const headers = parseCSVLine(lines[0]);
            const recs = [];
            for (let i = 1; i < lines.length; i++) {
                const fields = parseCSVLine(lines[i]);
                if (fields.length === headers.length) {
                    const r = {};
                    headers.forEach((h, j) => r[h] = fields[j].trim());
                    recs.push(r);
                }
            }
            return recs;
        }

        function parseCSVLine(line) {
            const fields = [];
            let field = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') { inQuotes = !inQuotes; continue; }
                if (char === ',' && !inQuotes) { fields.push(field); field = ''; continue; }
                field += char;
            }
            fields.push(field);
            return fields;
        }

        function buildCSV() {
            if (!records.length) return '';
            const headers = Object.keys(records[0]);
            const rows = [headers.map(escapeCSVField)];
            records.forEach(r => rows.push(headers.map(h => escapeCSVField(r[h] || ''))));
            return rows.join('\r\n') + '\r\n';
        }

        async function downloadCSV() {
            if (!records.length) return safeShowError('No data to save');
            if (!isInputCsv && !decryptionPassphrase) return safeShowError('No passphrase available');
            if (!exchangePassphrase && isEncryptedZip) return safeShowError('Exchange passphrase required for Dropbox upload');
            const csv = buildCSV();
            let blob;
            if (isInputCsv) {
                blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            } else {
                const zip = new JSZip();
                const csvFileName = `edited_${originalFileName.replace(/\.zip.*$/i, '')}.csv`;
                zip.file(csvFileName, csv);
                const zipBin = await zip.generateAsync({ type: 'uint8array' });
                const encrypted = encryptBlob(String.fromCharCode.apply(null, zipBin), decryptionPassphrase);
                const uint8 = new Uint8Array(encrypted.sigBytes);
                for (let i = 0; i < encrypted.sigBytes; i++) {
                    const w = encrypted.words[Math.floor(i / 4)];
                    uint8[i] = (w >>> (24 - (i % 4) * 8)) & 0xFF;
                }
                blob = new Blob([uint8], { type: 'application/octet-stream' });
            }
            if (isEncryptedZip) {
                try {
                    const accessToken = await getAccessToken();
                    const dbx = new Dropbox.Dropbox({ accessToken });
                    const fileHash = CryptoJS.SHA256(exchangePassphrase).toString();
                    const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
                    const dropboxPath = `${DROPBOX_FOLDER}/${fileHash}_edited_${timestamp}.zip`;
                    await dbx.filesUpload({ contents: blob, path: dropboxPath, mode: 'overwrite' });
                    showPopup(`Updated file saved to Dropbox as edited_${originalFileName}`);
                    hasReturnedUpdates = true;
                    document.getElementById('exitBtn').style.display = 'block';
                    document.getElementById('fileStatus').textContent = `Ticket ${ticketNumber} Records Returned`;
                } catch (err) {
                    safeShowError(`Failed to upload to Dropbox: ${err.message}`);
                }
            }
        }

        function dateToTimestamp(dateStr) {
            if (!dateStr) return Infinity;
            const parts = dateStr.split('-').map(Number);
            if (parts.length === 1) return parts[0] * 10000 * 100;
            if (parts.length === 2) return parts[0] * 10000 * 100 + parts[1] * 100;
            return parts[0] * 10000 * 100 + parts[1] * 100 + parts[2];
        }

        function isValidDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return true;
            const parts = dateStr.split('-');
            if (parts.length === 1) {
                const year = parseInt(parts[0], 10);
                return !isNaN(year) && year >= 1 && year <= 9999;
            } else if (parts.length === 2) {
                const year = parseInt(parts[0], 10);
                const month = parseInt(parts[1], 10);
                return !isNaN(year) && year >= 1 && year <= 9999 && !isNaN(month) && month >= 1 && month <= 12;
            } else if (parts.length === 3) {
                const date = Date.parse(dateStr + 'T00:00:00');
                if (isNaN(date)) return false;
                const parsedDate = new Date(date);
                return parsedDate.getFullYear() == parts[0] && (parsedDate.getMonth() + 1) == parts[1] && parsedDate.getDate() == parts[2];
            }
            return false;
        }

        function openModal(mode) {
            safeOpenModal(mode);
            const modalTitle = document.getElementById('modalTitle');
            const modalForm = document.getElementById('modalForm');
            let fields = [];
            if (mode === 'addChild') {
                modalTitle.textContent = 'Add Child';
                const selectablePeople = records.filter(r => r.record_type.toLowerCase() === 'person');
                fields = [
                    { name: 'parents', label: 'Genealogical Parent Name', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'sex', label: 'Sex', type: 'select', options: ['', 'male', 'female'] },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' }
                ];
            } else if (mode === 'addSpouse') {
                modalTitle.textContent = 'Add Partner';
                const selectablePeople = records.filter(r => r.record_type.toLowerCase() === 'person');
                fields = [
                    { name: 'partner', label: 'Select Genealogical Partner', type: 'select', options: ['', ...selectablePeople.map(r => r.name)], required: true },
                    { name: 'relationship', label: 'Relationship', type: 'select', options: ['', 'spouse', 'partner', 'other'], required: true },
                    { name: 'name', label: 'Name', type: 'text', autocomplete: 'off', required: true },
                    { name: 'birth_date', label: 'Birth Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'birth_location', label: 'Birth Location', type: 'text' },
                    { name: 'marriage_date', label: 'Marriage Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'parents', label: 'Parents', type: 'text', autocomplete: 'off' }
                ];
            } else if (mode === 'updateRecord') {
                modalTitle.textContent = 'Update Record';
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...records.map(r => `${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}`)], required: true },
                    { name: 'field', label: 'Field to Update', type: 'select', options: [''] },
                    { name: 'value', label: 'New Value', type: 'text', required: true }
                ];
            } else if (mode === 'recordDeathBurial') {
                modalTitle.textContent = 'Record Death/Burial';
                fields = [
                    { name: 'record', label: 'Select Record', type: 'select', options: ['', ...records.map(r => `${r.record_type.toLowerCase() === 'spouse' ? 'Partner' : r.record_type}: ${r.name}`)], required: true },
                    { name: 'death_date', label: 'Death Date (YYYY-MM-DD or YYYY-MM or YYYY)', type: 'text' },
                    { name: 'death_location', label: 'Death Location', type: 'text' },
                    { name: 'burial_location', label: 'Burial Location', type: 'text' }
                ];
            }
            fields.forEach(field => {
                const label = document.createElement('label');
                label.textContent = field.label;
                if (field.required) label.innerHTML += ' <span style="color:red">*</span>';
                modalForm.appendChild(label);
                if (field.type === 'select') {
                    const select = document.createElement('select');
                    select.name = field.name;
                    if (field.required) select.required = true;
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt || '(Select)';
                        select.appendChild(option);
                    });
                    modalForm.appendChild(select);
                } else {
                    const input = document.createElement(field.type === 'textarea' ? 'textarea' : 'input');
                    input.type = field.type;
                    input.name = field.name;
                    if (field.required) input.required = true;
                    if (field.autocomplete) input.setAttribute('autocomplete', field.autocomplete);
                    modalForm.appendChild(input);
                }
            });
            const submitBtn = document.createElement('button');
            submitBtn.type = 'button';
            submitBtn.textContent = 'Save';
            submitBtn.onclick = () => {
                if (submitBtn.disabled) return;
                submitBtn.disabled = true;
                setTimeout(() => submitBtn.disabled = false, 1000);
                saveModalData(mode);
            };
            modalForm.appendChild(submitBtn);
        }

        function closeModal() { safeCloseModal(); }

        function toggleTable() {
            const container = document.getElementById('tableContainer');
            if (container.style.display === 'none' || container.style.display === '') {
                container.style.display = 'block';
                debounceDisplayRecords();
            } else {
                container.style.display = 'none';
            }
        }

        function debounceDisplayRecords() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(displayRecords, 16);
        }

        function toggleColumn(column) {
            if (vestigialColumns.has(column)) {
                vestigialColumns.delete(column);
            } else {
                vestigialColumns.add(column);
            }
            debounceDisplayRecords();
        }

        function isFieldEditable(recordType, field) {
            const type = recordType.toLowerCase();
            const restrictions = fieldRestrictions[type];
            if (!restrictions) return false;
            return restrictions.editable.includes(field);
        }

        function displayRecords() {
            const body = document.getElementById('recordBody');
            body.innerHTML = '';
            if (records.length === 0) return;
            const table = document.createElement('table');
            const headers = Object.keys(records[000]).filter(h => !vestigialColumns.has(h));
            const hr = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                if (!['record_type','gen','name','sex'].includes(h)) {
                    const eye = document.createElement('span');
                    eye.textContent = vestigialColumns.has(h) ? 'ðŸ‘ï¸â€ðŸ—¨ï¸' : 'ðŸ‘ï¸';
                    eye.style.cursor = 'pointer';
                    eye.style.marginLeft = '8px';
                    eye.onclick = (e) => { e.stopPropagation(); toggleColumn(h); };
                    th.appendChild(eye);
                }
                hr.appendChild(th);
            });
            table.appendChild(hr);
            records.forEach((rec, idx) => {
                const tr = document.createElement('tr');
                headers.forEach(h => {
                    const td = document.createElement('td');
                    let value = rec[h] || '';
                    if (h === 'record_type' && value.toLowerCase() === 'spouse') value = 'Partner';
                    td.textContent = value;
                    if (isFieldEditable(rec.record_type, h)) {
                        td.style.cursor = 'pointer';
                        td.title = 'Click to edit';
                        td.onclick = () => alert('Inline editing not implemented â€” use modal buttons');
                    }
                    tr.appendChild(td);
                });
                table.appendChild(tr);
            });
            body.appendChild(table);
        }

        function initDebug() {
            if (window.location.search.includes('debug=1')) {
                (async () => {
                    const pp = await askPassphrase('DEBUG');
                    if (CryptoJS.SHA256(pp).toString() === debugPassphraseHash) {
                        debugMode = true;
                        console.log('DEBUG MODE ON');
                        document.getElementById('textFile').setAttribute('accept', '.zip,.csv');
                    }
                })();
            }
        }
        initDebug();
    </script>
</body>
</html>
